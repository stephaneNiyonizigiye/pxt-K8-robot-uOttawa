{"version":3,"file":"index.js","mappings":"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","sources":["webpack://@blockly/keyboard-navigation/webpack/universalModuleDefinition","webpack://@blockly/keyboard-navigation/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly\",\"commonjs2\":\"blockly\",\"amd\":\"blockly\"}","webpack://@blockly/keyboard-navigation/external umd {\"root\":\"Blockly\",\"commonjs\":\"blockly/core\",\"commonjs2\":\"blockly/core\",\"amd\":\"blockly/core\"}","webpack://@blockly/keyboard-navigation/webpack/bootstrap","webpack://@blockly/keyboard-navigation/webpack/runtime/define property getters","webpack://@blockly/keyboard-navigation/webpack/runtime/hasOwnProperty shorthand","webpack://@blockly/keyboard-navigation/webpack/runtime/make namespace object","webpack://@blockly/keyboard-navigation/./src/constants.ts","webpack://@blockly/keyboard-navigation/./src/toolbox_monkey_patch.js","webpack://@blockly/keyboard-navigation/./src/keynames.ts","webpack://@blockly/keyboard-navigation/./src/shortcut_formatting.ts","webpack://@blockly/keyboard-navigation/./src/hints.ts","webpack://@blockly/keyboard-navigation/./src/actions/clipboard.ts","webpack://@blockly/keyboard-navigation/./src/actions/delete.ts","webpack://@blockly/keyboard-navigation/./src/actions/edit.ts","webpack://@blockly/keyboard-navigation/./src/flyout_cursor.ts","webpack://@blockly/keyboard-navigation/./src/workspace_utilities.ts","webpack://@blockly/keyboard-navigation/./src/navigation.ts","webpack://@blockly/keyboard-navigation/./src/shortcut_dialog.ts","webpack://@blockly/keyboard-navigation/./src/actions/ws_movement.ts","webpack://@blockly/keyboard-navigation/./src/actions/arrow_navigation.ts","webpack://@blockly/keyboard-navigation/./src/actions/exit.ts","webpack://@blockly/keyboard-navigation/./src/drag_direction.ts","webpack://@blockly/keyboard-navigation/./src/move_indicator.ts","webpack://@blockly/keyboard-navigation/./src/move_icon.ts","webpack://@blockly/keyboard-navigation/./src/keyboard_drag_strategy.ts","webpack://@blockly/keyboard-navigation/./src/actions/mover.ts","webpack://@blockly/keyboard-navigation/./src/actions/enter.ts","webpack://@blockly/keyboard-navigation/./src/actions/disconnect.ts","webpack://@blockly/keyboard-navigation/./src/actions/action_menu.ts","webpack://@blockly/keyboard-navigation/./src/actions/move.ts","webpack://@blockly/keyboard-navigation/./src/actions/duplicate.ts","webpack://@blockly/keyboard-navigation/./src/actions/stack_navigation.ts","webpack://@blockly/keyboard-navigation/./src/navigation_controller.ts","webpack://@blockly/keyboard-navigation/./src/disabled_blocks.ts","webpack://@blockly/keyboard-navigation/./src/html_toast.ts","webpack://@blockly/keyboard-navigation/./src/index.ts"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"blockly/core\"), require(\"blockly\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"blockly/core\", \"blockly\"], factory);\n\telse {\n\t\tvar a = typeof exports === 'object' ? factory(require(\"blockly/core\"), require(\"blockly\")) : factory(root[\"Blockly\"], root[\"Blockly\"]);\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(this, (__WEBPACK_EXTERNAL_MODULE__370__, __WEBPACK_EXTERNAL_MODULE__826__) => {\nreturn ","module.exports = __WEBPACK_EXTERNAL_MODULE__826__;","module.exports = __WEBPACK_EXTERNAL_MODULE__370__;","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// define __esModule on exports\n__webpack_require__.r = (exports) => {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","/* eslint-disable @typescript-eslint/naming-convention */\n// The rules expect camel or pascal case enum members and record properties.\n\n/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Constants for keyboard navigation.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport {Msg} from 'blockly/core';\n\n/**\n * Keyboard navigation states.\n * The different parts of Blockly that the user navigates between.\n */\nexport enum STATE {\n  NOWHERE = 'nowhere',\n  WORKSPACE = 'workspace',\n  FLYOUT = 'flyout',\n  TOOLBOX = 'toolbox',\n}\n\n/**\n * Default keyboard navigation shortcut names.\n */\nexport enum SHORTCUT_NAMES {\n  UP = 'up',\n  DOWN = 'down',\n  RIGHT = 'right',\n  LEFT = 'left',\n  NEXT_STACK = 'next_stack',\n  PREVIOUS_STACK = 'previous_stack',\n  INSERT = 'insert',\n  EDIT_OR_CONFIRM = 'edit_or_confirm',\n  DISCONNECT = 'disconnect',\n  TOOLBOX = 'toolbox',\n  EXIT = 'exit',\n  MENU = 'menu',\n  COPY = 'keyboard_nav_copy',\n  CUT = 'keyboard_nav_cut',\n  PASTE = 'keyboard_nav_paste',\n  DUPLICATE = 'duplicate',\n  MOVE_WS_CURSOR_UP = 'workspace_up',\n  MOVE_WS_CURSOR_DOWN = 'workspace_down',\n  MOVE_WS_CURSOR_LEFT = 'workspace_left',\n  MOVE_WS_CURSOR_RIGHT = 'workspace_right',\n  CREATE_WS_CURSOR = 'to_workspace',\n  LIST_SHORTCUTS = 'list_shortcuts',\n  CLEAN_UP = 'clean_up_workspace',\n}\n\n/**\n * Types of possible messages passed into the loggingCallback in the Navigation\n * class.\n */\nexport enum LOGGING_MSG_TYPE {\n  ERROR = 'error',\n  WARN = 'warn',\n  LOG = 'log',\n}\n\n/**\n * Categories used to organised the shortcut dialog.\n * Shortcut name should match those obtained from the Blockly shortcut register.\n */\nexport const SHORTCUT_CATEGORIES: Record<\n  string,\n  // Also allow undo/redo. Document the non-keyboard-nav versions of others for\n  // better text because temporarily the name in the table is derived from\n  // these id-like names.\n  Array<SHORTCUT_NAMES | 'undo' | 'redo' | 'cut' | 'copy' | 'paste' | 'delete'>\n> = {};\n\nSHORTCUT_CATEGORIES[Msg['SHORTCUTS_GENERAL']] = [\n  SHORTCUT_NAMES.MENU,\n  SHORTCUT_NAMES.EDIT_OR_CONFIRM,\n  SHORTCUT_NAMES.EXIT,\n  SHORTCUT_NAMES.TOOLBOX,\n  SHORTCUT_NAMES.CLEAN_UP,\n  SHORTCUT_NAMES.LIST_SHORTCUTS,\n];\n\nSHORTCUT_CATEGORIES[Msg['SHORTCUTS_EDITING']] = [\n  SHORTCUT_NAMES.INSERT,\n  'delete',\n  SHORTCUT_NAMES.DISCONNECT,\n  'cut',\n  'copy',\n  'paste',\n  SHORTCUT_NAMES.DUPLICATE,\n  'undo',\n  'redo',\n];\n\nSHORTCUT_CATEGORIES[Msg['SHORTCUTS_CODE_NAVIGATION']] = [\n  SHORTCUT_NAMES.UP,\n  SHORTCUT_NAMES.DOWN,\n  SHORTCUT_NAMES.RIGHT,\n  SHORTCUT_NAMES.LEFT,\n  SHORTCUT_NAMES.NEXT_STACK,\n  SHORTCUT_NAMES.PREVIOUS_STACK,\n];\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\nBlockly.Toolbox.prototype.onKeyDown_ = function () {\n  // Do nothing since keyboard functionality should be entirely handled by the\n  // keyboard navigation plugin.\n};\n","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * Key names for common characters. These should be used with keyup/keydown\n * events, since the .keyCode property on those is meant to indicate the\n * _physical key_ the user held down on the keyboard. Hence the mapping uses\n * only the unshifted version of each key (e.g. no '#', since that's shift+3).\n * Keypress events on the other hand generate (mostly) ASCII codes since they\n * correspond to *characters* the user typed.\n *\n * For further reference: http://unixpapa.com/js/key.html\n *\n * This list is not localized and therefore some of the key codes are not\n * correct for non-US keyboard layouts.\n *\n * Copied from goog.events.keynames\n */\nexport const keyNames: Record<string, string> = {\n  /* eslint-disable @typescript-eslint/naming-convention */\n  8: 'backspace',\n  9: 'tab',\n  13: 'enter',\n  16: 'shift',\n  17: 'ctrl',\n  18: 'alt',\n  19: 'pause',\n  20: 'caps-lock',\n  27: 'esc',\n  32: 'space',\n  33: 'pg-up',\n  34: 'pg-down',\n  35: 'end',\n  36: 'home',\n  37: 'left',\n  38: 'up',\n  39: 'right',\n  40: 'down',\n  45: 'insert',\n  46: 'delete',\n  48: '0',\n  49: '1',\n  50: '2',\n  51: '3',\n  52: '4',\n  53: '5',\n  54: '6',\n  55: '7',\n  56: '8',\n  57: '9',\n  59: 'semicolon',\n  61: 'equals',\n  65: 'a',\n  66: 'b',\n  67: 'c',\n  68: 'd',\n  69: 'e',\n  70: 'f',\n  71: 'g',\n  72: 'h',\n  73: 'i',\n  74: 'j',\n  75: 'k',\n  76: 'l',\n  77: 'm',\n  78: 'n',\n  79: 'o',\n  80: 'p',\n  81: 'q',\n  82: 'r',\n  83: 's',\n  84: 't',\n  85: 'u',\n  86: 'v',\n  87: 'w',\n  88: 'x',\n  89: 'y',\n  90: 'z',\n  93: 'context',\n  96: 'num-0',\n  97: 'num-1',\n  98: 'num-2',\n  99: 'num-3',\n  100: 'num-4',\n  101: 'num-5',\n  102: 'num-6',\n  103: 'num-7',\n  104: 'num-8',\n  105: 'num-9',\n  106: 'num-multiply',\n  107: 'num-plus',\n  109: 'num-minus',\n  110: 'num-period',\n  111: 'num-division',\n  112: 'f1',\n  113: 'f2',\n  114: 'f3',\n  115: 'f4',\n  116: 'f5',\n  117: 'f6',\n  118: 'f7',\n  119: 'f8',\n  120: 'f9',\n  121: 'f10',\n  122: 'f11',\n  123: 'f12',\n  186: 'semicolon',\n  187: 'equals',\n  189: 'dash',\n  188: ',',\n  190: '.',\n  191: '/',\n  192: '`',\n  219: 'open-square-bracket',\n  220: '\\\\',\n  221: 'close-square-bracket',\n  222: 'single-quote',\n  224: 'win',\n  /* eslint-enable @typescript-eslint/naming-convention */\n};\n","import {ShortcutRegistry, Msg} from 'blockly';\nimport {keyNames} from './keynames';\n\nconst isMacPlatform = navigator.platform.startsWith('Mac');\n\n/**\n * Returns an HTML menu item with a label and grey keyboard shortcut.\n *\n * @param labelText The text of the mneu item.\n * @param action The identifier of an action to use the keyboard shortcut of.\n * @returns A nicely formatted menu item.\n */\nexport function getMenuItem(labelText: string, action: string): HTMLElement {\n  // TODO: Once core is updated to remove the shortcut placeholders from the\n  // keyboard shortcut messages, remove this.\n  if (labelText.indexOf(')') === labelText.length - 1) {\n    labelText = labelText.split(' (')[0];\n  }\n  const container = document.createElement('div');\n  container.className = 'blocklyShortcutContainer';\n  const label = document.createElement('span');\n  label.textContent = labelText;\n  const shortcut = document.createElement('span');\n  shortcut.className = 'blocklyShortcut';\n  shortcut.textContent = ` ${getShortActionShortcut(action)}`;\n  container.appendChild(label);\n  container.appendChild(shortcut);\n  return container;\n}\n\n/**\n * Find the primary shortcut for this platform and return it as single string\n * in a short user facing format.\n *\n * @param action The action name, e.g. \"cut\".\n * @returns The formatted shortcut.\n */\nexport function getShortActionShortcut(action: string): string {\n  const parts = getActionShortcutsAsKeys(action, shortModifierNames)[0];\n  return parts.join(isMacPlatform ? ' ' : ' + ');\n}\n\n/**\n * Find the relevant shortcuts for the given action for the current platform.\n * Keys are returned in a long user facing format.\n *\n * @param action The action name, e.g. \"cut\".\n * @returns The formatted shortcuts as individual keys.\n */\nexport function getLongActionShortcutsAsKeys(action: string): string[][] {\n  return getActionShortcutsAsKeys(action, longModifierNames);\n}\n\nconst longModifierNames: Record<string, string> = {\n  'Control': Msg['CONTROL_KEY'],\n  'Meta': Msg['COMMAND_KEY'],\n  'Alt': isMacPlatform ? Msg['OPTION_KEY'] : Msg['ALT_KEY'],\n};\n\nconst shortModifierNames: Record<string, string> = {\n  'Control': Msg['CONTROL_KEY'],\n  'Meta': '',\n  'Alt': isMacPlatform ? '' : Msg['ALT_KEY'],\n};\n\n/**\n * Find the relevant shortcuts for the given action for the current platform.\n * Keys are returned in a user facing format.\n *\n * This could be considerably simpler if we only bound shortcuts relevant to the\n * current platform or tagged them with a platform.\n *\n * @param action The action name, e.g. \"cut\".\n * @param modifierNames The names to use for the Meta/Control/Alt modifiers.\n * @returns The formatted shortcuts.\n */\nfunction getActionShortcutsAsKeys(\n  action: string,\n  modifierNames: Record<string, string>,\n): string[][] {\n  const shortcuts = ShortcutRegistry.registry.getKeyCodesByShortcutName(action);\n  // See ShortcutRegistry.createSerializedKey for the starting format.\n  const named = shortcuts.map((shortcut) => {\n    return shortcut\n      .split('+')\n      .map((maybeNumeric) => keyNames[maybeNumeric] ?? maybeNumeric)\n      .map((k) => upperCaseFirst(modifierNames[k] ?? k));\n  });\n\n  const command = modifierNames['Meta'];\n  const option = modifierNames['Alt'];\n  const control = modifierNames['Control'];\n  // Needed to prefer Command to Option where we've bound Alt.\n  named.sort((a, b) => {\n    const aValue = a.includes(command) ? 1 : 0;\n    const bValue = b.includes(command) ? 1 : 0;\n    return bValue - aValue;\n  });\n  let currentPlatform = named.filter((shortcut) => {\n    const isMacShortcut =\n      shortcut.includes(command) || shortcut.includes(option);\n    return isMacShortcut === isMacPlatform;\n  });\n  currentPlatform = currentPlatform.length === 0 ? named : currentPlatform;\n\n  // If there are modifiers return only one shortcut on the assumption they are\n  // intended for different platforms. Otherwise assume they are alternatives.\n  const hasModifiers = currentPlatform.some((shortcut) =>\n    shortcut.some(\n      (key) => command === key || option === key || control === key,\n    ),\n  );\n  return hasModifiers ? [currentPlatform[0]] : currentPlatform;\n}\n\n/**\n * Convert the first character to uppercase.\n *\n * @param str String.\n * @returns The string in title case.\n */\nexport function upperCaseFirst(str: string) {\n  return str.charAt(0).toUpperCase() + str.substring(1);\n}\n","/**\n * Centralises hints that we show.\n *\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {Msg, WorkspaceSvg, Toast} from 'blockly';\nimport {SHORTCUT_NAMES} from './constants';\nimport {getShortActionShortcut} from './shortcut_formatting';\n\nconst unconstrainedMoveHintId = 'unconstrainedMoveHint';\nconst constrainedMoveHintId = 'constrainedMoveHint';\nconst copiedHintId = 'copiedHint';\nconst cutHintId = 'cutHint';\nconst helpHintId = 'helpHint';\n\n/**\n * Nudge the user to use unconstrained movement.\n *\n * @param workspace Workspace.\n * @param force Set to show it even if previously shown.\n */\nexport function showUnconstrainedMoveHint(\n  workspace: WorkspaceSvg,\n  force = false,\n) {\n  const enter = getShortActionShortcut(SHORTCUT_NAMES.EDIT_OR_CONFIRM);\n  const modifier = navigator.platform.startsWith('Mac') ? '' : 'Ctrl';\n  const message = `Hold ${modifier} and use arrow keys to move freely, then ${enter} to accept the position`;\n  Toast.show(workspace, {\n    message,\n    id: unconstrainedMoveHintId,\n    oncePerSession: !force,\n  });\n}\n\n/**\n * Nudge the user to move a block that's in move mode.\n *\n * @param workspace Workspace.\n */\nexport function showConstrainedMovementHint(workspace: WorkspaceSvg) {\n  const enter = getShortActionShortcut(SHORTCUT_NAMES.EDIT_OR_CONFIRM);\n  const message = `Use the arrow keys to move, then ${enter} to accept the position`;\n  Toast.show(workspace, {\n    message,\n    id: constrainedMoveHintId,\n    oncePerSession: true,\n  });\n}\n\n/**\n * Clear active move-related hints, if any.\n *\n * @param workspace The workspace.\n */\nexport function clearMoveHints(workspace: WorkspaceSvg) {\n  Toast.hide(workspace, constrainedMoveHintId);\n  Toast.hide(workspace, unconstrainedMoveHintId);\n}\n\n/**\n * Nudge the user to paste after a copy.\n *\n * @param workspace Workspace.\n */\nexport function showCopiedHint(workspace: WorkspaceSvg) {\n  Toast.show(workspace, {\n    message: `Copied. Press ${getShortActionShortcut(SHORTCUT_NAMES.PASTE)} to paste.`,\n    duration: 7,\n    id: copiedHintId,\n  });\n}\n\n/**\n * Nudge the user to paste after a cut.\n *\n * @param workspace Workspace.\n */\nexport function showCutHint(workspace: WorkspaceSvg) {\n  Toast.show(workspace, {\n    message: `Cut. Press ${getShortActionShortcut(SHORTCUT_NAMES.PASTE)} to paste.`,\n    duration: 7,\n    id: cutHintId,\n  });\n}\n\n/**\n * Clear active paste-related hints, if any.\n *\n * @param workspace The workspace.\n */\nexport function clearPasteHints(workspace: WorkspaceSvg) {\n  Toast.hide(workspace, cutHintId);\n  Toast.hide(workspace, copiedHintId);\n}\n\n/**\n * Nudge the user to open the help.\n *\n * @param workspace The workspace.\n */\nexport function showHelpHint(workspace: WorkspaceSvg) {\n  const shortcut = getShortActionShortcut('list_shortcuts');\n  const message = Msg['HELP_PROMPT'].replace('%1', shortcut);\n  const id = helpHintId;\n  Toast.show(workspace, {message, id});\n}\n\n/**\n * Clear the help hint.\n *\n * @param workspace The workspace.\n */\nexport function clearHelpHint(workspace: WorkspaceSvg) {\n  // TODO: We'd like to do this in MakeCode too as we override.\n  // Could have an option for showing help in the plugin?\n  Toast.hide(workspace, helpHintId);\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  ContextMenuRegistry,\n  ShortcutRegistry,\n  isCopyable,\n  Msg,\n  ShortcutItems,\n  WorkspaceSvg,\n  clipboard,\n  isSelectable,\n} from 'blockly';\nimport * as Constants from '../constants';\nimport {Navigation} from '../navigation';\nimport {getMenuItem} from '../shortcut_formatting';\nimport {clearPasteHints, showCopiedHint, showCutHint} from '../hints';\n\n/**\n * Weight for the first of these three items in the context menu.\n * Changing base weight will change where this group goes in the context\n * menu; changing individual weights relative to base weight can change\n * the order within the clipboard group.\n */\nconst BASE_WEIGHT = 12;\n\n/**\n * Logic and state for cut/copy/paste actions as both keyboard shortcuts\n * and context menu items.\n * In the long term, this will likely merge with the clipboard code in core.\n */\nexport class Clipboard {\n  private oldCutShortcut: ShortcutRegistry.KeyboardShortcut | undefined;\n  private oldCopyShortcut: ShortcutRegistry.KeyboardShortcut | undefined;\n  private oldPasteShortcut: ShortcutRegistry.KeyboardShortcut | undefined;\n\n  constructor(\n    private navigation: Navigation,\n    private options: {allowCrossWorkspacePaste: boolean} = {\n      allowCrossWorkspacePaste: false,\n    },\n  ) {}\n\n  /**\n   * Install these actions as both keyboard shortcuts and context menu items.\n   */\n  install() {\n    this.registerCopyShortcut();\n    this.registerCopyContextMenuAction();\n\n    this.registerPasteShortcut();\n    this.registerPasteContextMenuAction();\n\n    this.registerCutShortcut();\n    this.registerCutContextMenuAction();\n  }\n\n  /**\n   * Uninstall this action as both a keyboard shortcut and a context menu item.\n   * N. B. This does *not* currently reinstall the original keyboard shortcuts.\n   * You should manually reinstall the previously registered shortcuts (either\n   * from core or from another plugin you may be using).\n   */\n  uninstall() {\n    ContextMenuRegistry.registry.unregister('blockCutFromContextMenu');\n    ContextMenuRegistry.registry.unregister('blockCopyFromContextMenu');\n    ContextMenuRegistry.registry.unregister('blockPasteFromContextMenu');\n\n    ShortcutRegistry.registry.unregister(Constants.SHORTCUT_NAMES.CUT);\n    ShortcutRegistry.registry.unregister(Constants.SHORTCUT_NAMES.COPY);\n    ShortcutRegistry.registry.unregister(Constants.SHORTCUT_NAMES.PASTE);\n  }\n\n  /**\n   * Create and register the keyboard shortcut for the cut action.\n   * Identical to the one in core but adds a toast after successful cut.\n   */\n  private registerCutShortcut() {\n    this.oldCutShortcut =\n      ShortcutRegistry.registry.getRegistry()[ShortcutItems.names.CUT];\n    if (!this.oldCutShortcut)\n      throw new Error('No cut keyboard shortcut registered initially');\n\n    const cutShortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.CUT,\n      preconditionFn: this.oldCutShortcut.preconditionFn,\n      callback: this.cutCallback.bind(this),\n      keyCodes: this.oldCutShortcut.keyCodes,\n      allowCollision: false,\n    };\n\n    ShortcutRegistry.registry.unregister(ShortcutItems.names.CUT);\n    ShortcutRegistry.registry.register(cutShortcut);\n  }\n\n  /**\n   * Register the cut block action as a context menu item.\n   * The context menu uses its own preconditionFn (that doesn't check\n   * if a gesture is in progress, because one always is in the context\n   * menu). It calls the cut callback that is shared between keyboard\n   * and context menu.\n   */\n  private registerCutContextMenuAction() {\n    const cutAction: ContextMenuRegistry.RegistryItem = {\n      displayText: (scope) =>\n        getMenuItem(Msg['CUT_SHORTCUT'], Constants.SHORTCUT_NAMES.CUT),\n      preconditionFn: (scope) => this.cutPrecondition(scope),\n      callback: (scope, menuOpenEvent) => {\n        if (!isCopyable(scope.focusedNode)) return false;\n        const ws = scope.focusedNode.workspace;\n        if (!(ws instanceof WorkspaceSvg)) return false;\n\n        return this.cutCallback(ws, menuOpenEvent, undefined, scope);\n      },\n      id: 'blockCutFromContextMenu',\n      weight: BASE_WEIGHT,\n    };\n\n    ContextMenuRegistry.registry.register(cutAction);\n  }\n\n  /**\n   * Precondition function for the cut context menu. This wraps the core cut\n   * precondition to support context menus.\n   *\n   * @param scope scope of the shortcut or context menu item\n   * @returns 'enabled' if the node can be cut, 'disabled' otherwise.\n   */\n  private cutPrecondition(scope: ContextMenuRegistry.Scope): string {\n    const focused = scope.focusedNode;\n    if (!focused || !isCopyable(focused)) return 'hidden';\n\n    const workspace = focused.workspace;\n    if (!(workspace instanceof WorkspaceSvg)) return 'hidden';\n\n    if (\n      this.oldCutShortcut?.preconditionFn &&\n      this.oldCutShortcut.preconditionFn(workspace, scope)\n    ) {\n      return 'enabled';\n    }\n    return 'disabled';\n  }\n\n  /**\n   * The callback for the cut action. Uses the registered version of the cut callback\n   * to perform the cut logic, then pops a toast if cut happened.\n   *\n   * @param workspace Workspace where shortcut happened.\n   * @param e menu open event or keyboard event\n   * @param shortcut keyboard shortcut or undefined for context menus\n   * @param scope scope of the shortcut or context menu item\n   * @returns true if a cut happened, false otherwise\n   */\n  private cutCallback(\n    workspace: WorkspaceSvg,\n    e: Event,\n    shortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.CUT,\n    },\n    scope: ContextMenuRegistry.Scope,\n  ) {\n    const didCut =\n      !!this.oldCutShortcut?.callback &&\n      this.oldCutShortcut.callback(workspace, e, shortcut, scope);\n    if (didCut) {\n      showCutHint(workspace);\n    }\n    return didCut;\n  }\n\n  /**\n   * Create and register the keyboard shortcut for the copy action.\n   * Identical to the one in core but pops a toast after succesful copy.\n   */\n  private registerCopyShortcut() {\n    this.oldCopyShortcut =\n      ShortcutRegistry.registry.getRegistry()[ShortcutItems.names.COPY];\n    if (!this.oldCopyShortcut)\n      throw new Error('No copy keyboard shortcut registered initially');\n\n    const copyShortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.COPY,\n      preconditionFn: this.oldCopyShortcut.preconditionFn,\n      callback: this.copyCallback.bind(this),\n      keyCodes: this.oldCopyShortcut.keyCodes,\n      allowCollision: false,\n    };\n\n    ShortcutRegistry.registry.unregister(ShortcutItems.names.COPY);\n    ShortcutRegistry.registry.register(copyShortcut);\n  }\n\n  /**\n   * Register the copy block action as a context menu item.\n   * The context menu uses its own preconditionFn (that doesn't check\n   * if a gesture is in progress, because one always is in the context\n   * menu). It calls the copy callback that is shared between keyboard\n   * and context menu.\n   */\n  private registerCopyContextMenuAction() {\n    const copyAction: ContextMenuRegistry.RegistryItem = {\n      displayText: (scope) =>\n        getMenuItem(Msg['COPY_SHORTCUT'], Constants.SHORTCUT_NAMES.COPY),\n      preconditionFn: (scope) => this.copyPrecondition(scope),\n      callback: (scope, menuOpenEvent) => {\n        if (!isCopyable(scope.focusedNode)) return false;\n        const ws = scope.focusedNode.workspace;\n        if (!(ws instanceof WorkspaceSvg)) return false;\n\n        return this.copyCallback(ws, menuOpenEvent, undefined, scope);\n      },\n      id: 'blockCopyFromContextMenu',\n      weight: BASE_WEIGHT + 1,\n    };\n\n    ContextMenuRegistry.registry.register(copyAction);\n  }\n\n  /**\n   * Precondition function for the copy context menu. This wraps the core copy\n   * precondition to support context menus.\n   *\n   * @param scope scope of the shortcut or context menu item\n   * @returns 'enabled' if the node can be copied, 'disabled' otherwise.\n   */\n  private copyPrecondition(scope: ContextMenuRegistry.Scope): string {\n    const focused = scope.focusedNode;\n    if (!focused || !isCopyable(focused)) return 'hidden';\n\n    const workspace = focused.workspace;\n    if (!(workspace instanceof WorkspaceSvg)) return 'hidden';\n\n    if (\n      this.oldCopyShortcut?.preconditionFn &&\n      this.oldCopyShortcut.preconditionFn(workspace, scope)\n    ) {\n      return 'enabled';\n    }\n    return 'disabled';\n  }\n\n  /**\n   * The callback for the copy action. Uses the registered version of the copy callback\n   * to perform the copy logic, then pops a toast if copy happened.\n   *\n   * @param workspace Workspace where shortcut happened.\n   * @param e menu open event or keyboard event\n   * @param shortcut keyboard shortcut or undefined for context menus\n   * @param scope scope of the shortcut or context menu item\n   * @returns true if a copy happened, false otherwise\n   */\n  private copyCallback(\n    workspace: WorkspaceSvg,\n    e: Event,\n    shortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.CUT,\n    },\n    scope: ContextMenuRegistry.Scope,\n  ) {\n    const didCopy =\n      !!this.oldCopyShortcut?.callback &&\n      this.oldCopyShortcut.callback(workspace, e, shortcut, scope);\n    if (didCopy) {\n      showCopiedHint(workspace);\n    }\n    return didCopy;\n  }\n\n  /**\n   * Create and register the keyboard shortcut for the paste action.\n   * Identical to the one in core but clears any paste toasts after.\n   */\n  private registerPasteShortcut() {\n    this.oldPasteShortcut =\n      ShortcutRegistry.registry.getRegistry()[ShortcutItems.names.PASTE];\n    if (!this.oldPasteShortcut)\n      throw new Error('No paste keyboard shortcut registered initially');\n\n    const pasteShortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.PASTE,\n      preconditionFn: this.oldPasteShortcut.preconditionFn,\n      callback: this.pasteCallback.bind(this),\n      keyCodes: this.oldPasteShortcut.keyCodes,\n      allowCollision: false,\n    };\n\n    ShortcutRegistry.registry.unregister(ShortcutItems.names.PASTE);\n    ShortcutRegistry.registry.register(pasteShortcut);\n  }\n\n  /**\n   * Register the paste block action as a context menu item.\n   * The context menu uses its own preconditionFn (that doesn't check\n   * if a gesture is in progress, because one always is in the context\n   * menu). It calls the paste callback that is shared between keyboard\n   * and context menu.\n   */\n  private registerPasteContextMenuAction() {\n    const pasteAction: ContextMenuRegistry.RegistryItem = {\n      displayText: (scope) =>\n        getMenuItem(Msg['PASTE_SHORTCUT'], Constants.SHORTCUT_NAMES.PASTE),\n      preconditionFn: (scope) => this.pastePrecondition(scope),\n      callback: (scope: ContextMenuRegistry.Scope, menuOpenEvent: Event) => {\n        const workspace = this.getPasteWorkspace(scope);\n        if (!workspace) return false;\n        return this.pasteCallback(workspace, menuOpenEvent, undefined, scope);\n      },\n      id: 'blockPasteFromContextMenu',\n      weight: BASE_WEIGHT + 2,\n    };\n\n    ContextMenuRegistry.registry.register(pasteAction);\n  }\n\n  /**\n   * Get the workspace to paste into based on which type of thing the menu was opened on.\n   *\n   * @param scope scope of shortcut or context menu item\n   * @returns WorkspaceSvg to paste into or undefined\n   */\n  private getPasteWorkspace(\n    scope: ContextMenuRegistry.Scope,\n  ): WorkspaceSvg | undefined {\n    let workspace;\n    if (scope.focusedNode instanceof WorkspaceSvg) {\n      workspace = scope.focusedNode;\n    } else if (isSelectable(scope.focusedNode)) {\n      workspace = scope.focusedNode.workspace;\n    }\n\n    if (!workspace || !(workspace instanceof WorkspaceSvg)) return undefined;\n    return workspace;\n  }\n\n  /**\n   * Precondition function for the paste context menu. This wraps the core\n   * paste precondition to support context menus.\n   *\n   * @param scope scope of the shortcut or context menu item\n   * @returns 'enabled' if the node can be pasted, 'disabled' otherwise.\n   */\n  private pastePrecondition(scope: ContextMenuRegistry.Scope): string {\n    const workspace = this.getPasteWorkspace(scope);\n    // If we can't identify what workspace to paste into, hide.\n    if (!workspace) return 'hidden';\n\n    // Don't paste into flyouts.\n    if (workspace.isFlyout) return 'hidden';\n\n    if (!this.options.allowCrossWorkspacePaste) {\n      // Only paste into the same workspace that was copied from\n      // or the parent workspace of a flyout that was copied from.\n      let copiedWorkspace = clipboard.getLastCopiedWorkspace();\n      if (copiedWorkspace?.isFlyout)\n        copiedWorkspace = copiedWorkspace.targetWorkspace;\n      if (copiedWorkspace !== workspace) return 'disabled';\n    }\n\n    if (\n      this.oldPasteShortcut?.preconditionFn &&\n      this.oldPasteShortcut.preconditionFn(workspace, scope)\n    ) {\n      return 'enabled';\n    }\n    return 'disabled';\n  }\n\n  /**\n   * The callback for the paste action. Uses the registered version of the paste callback\n   * to perform the paste logic, then clears any toasts about pasting.\n   *\n   * @param workspace Workspace where shortcut happened.\n   * @param e menu open event or keyboard event\n   * @param shortcut keyboard shortcut or undefined for context menus\n   * @param scope scope of the shortcut or context menu item\n   * @returns true if a paste happened, false otherwise\n   */\n  private pasteCallback(\n    workspace: WorkspaceSvg,\n    e: Event,\n    shortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.CUT,\n    },\n    scope: ContextMenuRegistry.Scope,\n  ) {\n    const didPaste =\n      !!this.oldPasteShortcut?.callback &&\n      this.oldPasteShortcut.callback(workspace, e, shortcut, scope);\n\n    // Clear the paste hints regardless of whether something was pasted\n    // Some implementations of paste are async and we should clear the hint\n    // once the user initiates the paste action.\n    clearPasteHints(workspace);\n    return didPaste;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ContextMenuRegistry, Msg, ShortcutItems} from 'blockly';\nimport {getMenuItem} from '../shortcut_formatting';\n\n/**\n * Action to delete the block the cursor is currently on.\n */\nexport class DeleteAction {\n  /**\n   * Saved context menu item display text function, which is restored\n   * when this action is uninstalled.\n   */\n  private oldDisplayText:\n    | ((scope: ContextMenuRegistry.Scope) => string | HTMLElement)\n    | string\n    | HTMLElement\n    | undefined = undefined;\n\n  /**\n   * Saved context menu item, which has its display text restored when\n   * this action is uninstalled.\n   */\n  private oldContextMenuItem: ContextMenuRegistry.RegistryItem | null = null;\n\n  constructor() {}\n\n  /**\n   * Install this action as both a keyboard shortcut and a context menu item.\n   */\n  install() {\n    this.registerContextMenuAction();\n  }\n\n  /**\n   * Reinstall the original context menu display text if possible.\n   */\n  uninstall() {\n    if (this.oldContextMenuItem && this.oldDisplayText) {\n      this.oldContextMenuItem.displayText = this.oldDisplayText;\n    }\n  }\n\n  /**\n   * Updates the text of the context menu delete action to include\n   * the keyboard shortcut.\n   */\n  private registerContextMenuAction() {\n    this.oldContextMenuItem =\n      ContextMenuRegistry.registry.getItem('blockDelete');\n\n    if (!this.oldContextMenuItem) return;\n\n    this.oldDisplayText = this.oldContextMenuItem.displayText;\n\n    const displayText = (scope: ContextMenuRegistry.Scope) => {\n      let label: string;\n      // Use the original item's text, which is dynamic based on the number\n      // of blocks that will be deleted.\n      if (typeof this.oldDisplayText === 'function') {\n        const result = this.oldDisplayText(scope);\n        if (result instanceof HTMLElement) {\n          label = result.innerText;\n        } else {\n          label = result;\n        }\n      } else if (typeof this.oldDisplayText === 'string') {\n        label = this.oldDisplayText;\n      } else {\n        label = Msg['DELETE_BLOCK'];\n      }\n\n      return getMenuItem(label, ShortcutItems.names.DELETE);\n    };\n\n    this.oldContextMenuItem.displayText = displayText;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  ContextMenuRegistry,\n  LineCursor,\n  Msg,\n  keyboardNavigationController,\n} from 'blockly';\nimport {Navigation} from 'src/navigation';\nimport {getMenuItem} from '../shortcut_formatting';\nimport * as Constants from '../constants';\n\n/**\n * Action to edit a block.  This just moves the cursor to the first\n * field or input (if there is one), and exists as an aid to\n * navigational discoverability:\n *\n * Any time there is a cursor position that can be accessed by\n * pressing the right-arrow key, which isn't accessible by pressing\n * the down-arrow key (these positions are typically fields and value\n * inputs), a context menu item \"Edit Block contents ()\" will be\n * shown in the block context menu.\n *\n * N.B.: This item is shown any time the cursor is on a block and not\n * in the rightmost position 'on the current line'; that means that\n * sometimes the label (\"Edit block contents\") is possibly misleading,\n * because it might not be the contents of the _current_ block that's\n * being edited, but rather that of a sibling or parent block.\n *\n * This action registers itself only as a context menu item, as there\n * is already a corresponding \"right\" shortcut item.\n */\nexport class EditAction {\n  constructor(private navigation: Navigation) {}\n\n  /**\n   * Install this action as a context menu item.\n   */\n  install() {\n    this.registerContextMenuAction();\n  }\n\n  /**\n   * Uninstall this action as both a keyboard shortcut and a context menu item.\n   * Reinstall the original context menu action if possible.\n   */\n  uninstall() {\n    ContextMenuRegistry.registry.unregister('edit');\n  }\n\n  /**\n   * Register the edit block action as a context menu item on blocks.\n   */\n  private registerContextMenuAction() {\n    const editAboveItem: ContextMenuRegistry.RegistryItem = {\n      displayText: getMenuItem(\n        Msg['EDIT_BLOCK_CONTENTS'],\n        Constants.SHORTCUT_NAMES.RIGHT,\n      ),\n      preconditionFn: (scope: ContextMenuRegistry.Scope, menuOpenEvent) => {\n        if (menuOpenEvent instanceof PointerEvent) return 'hidden';\n        const workspace = scope.block?.workspace;\n        if (!workspace || !this.navigation.canCurrentlyNavigate(workspace)) {\n          return 'disabled';\n        }\n        const cursor = workspace.getCursor() as LineCursor | null;\n        if (!cursor) return 'disabled';\n        return cursor.atEndOfLine() ? 'hidden' : 'enabled';\n      },\n      callback: (scope: ContextMenuRegistry.Scope) => {\n        keyboardNavigationController.setIsActive(true);\n        const workspace = scope.block?.workspace;\n        if (!workspace) return false;\n        workspace.getCursor()?.in();\n        return true;\n      },\n      scopeType: ContextMenuRegistry.ScopeType.BLOCK,\n      id: 'edit',\n      weight: 10,\n    };\n\n    ContextMenuRegistry.registry.register(editAboveItem);\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview The class representing a cursor used to navigate the flyout.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\nimport {scrollBoundsIntoView} from './workspace_utilities';\n\n/**\n * Class for a flyout cursor.\n * This controls how a user navigates blocks in the flyout.\n * This cursor only allows a user to go to the previous or next stack.\n */\nexport class FlyoutCursor extends Blockly.LineCursor {\n  /**\n   * The constructor for the FlyoutCursor.\n   *\n   * @param flyout The flyout this cursor is for.\n   */\n  constructor(private readonly flyout: Blockly.IFlyout) {\n    super(flyout.getWorkspace());\n  }\n\n  /**\n   * Moves the cursor to the next stack of blocks in the flyout.\n   *\n   * @returns The next element, or null if the current node is\n   *     not set or there is no next value.\n   */\n  override next(): Blockly.IFocusableNode | null {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.workspace.getNavigator().getNextSibling(curNode);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  /**\n   * Moves the cursor to the previous stack of blocks in the flyout.\n   *\n   * @returns The previous element, or null if the current\n   *     node is not set or there is no previous value.\n   */\n  override prev(): Blockly.IFocusableNode | null {\n    const curNode = this.getCurNode();\n    if (!curNode) {\n      return null;\n    }\n    const newNode = this.workspace.getNavigator().getPreviousSibling(curNode);\n\n    if (newNode) {\n      this.setCurNode(newNode);\n    }\n    return newNode;\n  }\n\n  override setCurNode(node: Blockly.IFocusableNode) {\n    super.setCurNode(node);\n\n    let bounds: Blockly.utils.Rect | undefined;\n    if (\n      node &&\n      'getBoundingRectangle' in node &&\n      typeof node.getBoundingRectangle === 'function'\n    ) {\n      bounds = node.getBoundingRectangle();\n    } else if (node instanceof Blockly.FlyoutButton) {\n      const {x, y} = node.getPosition();\n      bounds = new Blockly.utils.Rect(y, y + node.height, x, x + node.width);\n    }\n\n    if (!(bounds instanceof Blockly.utils.Rect)) return;\n\n    scrollBoundsIntoView(bounds, this.flyout.getWorkspace());\n  }\n}\n\nexport const registrationType = Blockly.registry.Type.CURSOR;\nexport const registrationName = 'FlyoutCursor';\n\nBlockly.registry.register(registrationType, registrationName, FlyoutCursor);\n\nexport const pluginInfo = {\n  [registrationType.toString()]: registrationName,\n};\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Scrolls the provided bounds into view.\n *\n * In the case of small workspaces/large bounds, this function prioritizes\n * getting the top left corner of the bounds into view. It also adds some\n * padding around the bounds to allow the element to be comfortably in view.\n *\n * @param bounds A rectangle to scroll into view, as best as possible.\n * @param workspace The workspace to scroll the given bounds into view in.\n */\nexport function scrollBoundsIntoView(\n  bounds: Blockly.utils.Rect,\n  workspace: Blockly.WorkspaceSvg,\n) {\n  if (Blockly.Gesture.inProgress()) {\n    // This can cause jumps during a drag and it only suited for keyboard nav.\n    return;\n  }\n  const scale = workspace.getScale();\n\n  const rawViewport = workspace.getMetricsManager().getViewMetrics(true);\n  const viewport = new Blockly.utils.Rect(\n    rawViewport.top,\n    rawViewport.top + rawViewport.height,\n    rawViewport.left,\n    rawViewport.left + rawViewport.width,\n  );\n\n  if (\n    bounds.left >= viewport.left &&\n    bounds.top >= viewport.top &&\n    bounds.right <= viewport.right &&\n    bounds.bottom <= viewport.bottom\n  ) {\n    // Do nothing if the block is fully inside the viewport.\n    return;\n  }\n\n  // Add some padding to the bounds so the element is scrolled comfortably\n  // into view.\n  bounds = bounds.clone();\n  bounds.top -= 10;\n  bounds.bottom += 10;\n  bounds.left -= 10;\n  bounds.right += 10;\n\n  let deltaX = 0;\n  let deltaY = 0;\n\n  if (bounds.left < viewport.left) {\n    deltaX = viewport.left - bounds.left;\n  } else if (bounds.right > viewport.right) {\n    deltaX = viewport.right - bounds.right;\n  }\n\n  if (bounds.top < viewport.top) {\n    deltaY = viewport.top - bounds.top;\n  } else if (bounds.bottom > viewport.bottom) {\n    deltaY = viewport.bottom - bounds.bottom;\n  }\n\n  deltaX *= scale;\n  deltaY *= scale;\n  workspace.scroll(workspace.scrollX + deltaX, workspace.scrollY + deltaY);\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Holds all methods necessary to use Blockly through the\n * keyboard.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport * as Blockly from 'blockly/core';\nimport * as Constants from './constants';\nimport {\n  registrationName as cursorRegistrationName,\n  registrationType as cursorRegistrationType,\n} from './flyout_cursor';\n\n/**\n * Class that holds all methods necessary for keyboard navigation to work.\n */\nexport class Navigation {\n  /**\n   * Wrapper for method that deals with workspace changes.\n   * Used for removing change listener.\n   */\n  protected wsChangeWrapper: (e: Blockly.Events.Abstract) => void;\n\n  /**\n   * Wrapper for method that deals with flyout changes.\n   * Used for removing change listener.\n   */\n  protected flyoutChangeWrapper: (e: Blockly.Events.Abstract) => void;\n\n  /**\n   * The list of registered workspaces.\n   * Used when removing change listeners in dispose.\n   */\n  protected workspaces: Blockly.WorkspaceSvg[] = [];\n\n  /**\n   * Constructor for keyboard navigation.\n   */\n  constructor() {\n    this.wsChangeWrapper = this.workspaceChangeListener.bind(this);\n    this.flyoutChangeWrapper = this.flyoutChangeListener.bind(this);\n  }\n\n  /**\n   * Adds all necessary change listeners and markers to a workspace for keyboard\n   * navigation to work. This must be called for keyboard navigation to work\n   * on a workspace.\n   *\n   * @param workspace The workspace to add keyboard navigation to.\n   */\n  addWorkspace(workspace: Blockly.WorkspaceSvg) {\n    this.workspaces.push(workspace);\n    const flyout = workspace.getFlyout();\n    workspace.addChangeListener(this.wsChangeWrapper);\n\n    if (flyout) {\n      this.addFlyout(flyout);\n    }\n  }\n\n  /**\n   * Removes all keyboard navigation change listeners and markers.\n   *\n   * @param workspace The workspace to remove keyboard navigation from.\n   */\n  removeWorkspace(workspace: Blockly.WorkspaceSvg) {\n    const workspaceIdx = this.workspaces.indexOf(workspace);\n    const flyout = workspace.getFlyout();\n\n    if (workspace.getCursor()) {\n      this.disableKeyboardAccessibility(workspace);\n    }\n\n    if (workspaceIdx > -1) {\n      this.workspaces.splice(workspaceIdx, 1);\n    }\n    workspace.removeChangeListener(this.wsChangeWrapper);\n\n    if (flyout) {\n      this.removeFlyout(flyout);\n    }\n  }\n\n  /**\n   * Gets the navigation state of the current workspace.\n   *\n   * Note that this assumes a workspace with passive focus (including for its\n   * toolbox or flyout) has a state of NOWHERE.\n   *\n   * @returns The state of the given workspace.\n   */\n  getState(): Constants.STATE {\n    const focusManager = Blockly.getFocusManager();\n    if (focusManager.ephemeralFocusTaken()) {\n      return Constants.STATE.NOWHERE;\n    }\n\n    const focusedTree = focusManager.getFocusedTree();\n    if (focusedTree instanceof Blockly.WorkspaceSvg) {\n      if (focusedTree.isFlyout) {\n        return Constants.STATE.FLYOUT;\n      } else {\n        return Constants.STATE.WORKSPACE;\n      }\n    } else if (focusedTree instanceof Blockly.Toolbox) {\n      return Constants.STATE.TOOLBOX;\n    } else if (focusedTree instanceof Blockly.Flyout) {\n      return Constants.STATE.FLYOUT;\n    }\n    // Either a non-Blockly element currently has DOM focus, or a different\n    // workspace holds it.\n    return Constants.STATE.NOWHERE;\n  }\n\n  /**\n   * Adds all event listeners and cursors to the flyout that are needed for\n   * keyboard navigation to work.\n   *\n   * @param flyout The flyout to add a cursor and change listeners to.\n   */\n  addFlyout(flyout: Blockly.IFlyout) {\n    const flyoutWorkspace = flyout.getWorkspace();\n    flyoutWorkspace.addChangeListener(this.flyoutChangeWrapper);\n    const FlyoutCursorClass = Blockly.registry.getClass(\n      cursorRegistrationType,\n      cursorRegistrationName,\n    );\n    if (FlyoutCursorClass) {\n      flyoutWorkspace\n        .getMarkerManager()\n        .setCursor(new FlyoutCursorClass(flyout));\n    }\n  }\n\n  /**\n   * Removes all change listeners from the flyout that are needed for\n   * keyboard navigation to work.\n   *\n   * @param flyout The flyout to add a cursor and event listeners to.\n   */\n  removeFlyout(flyout: Blockly.IFlyout) {\n    const flyoutWorkspace = flyout.getWorkspace();\n    flyoutWorkspace.removeChangeListener(this.flyoutChangeWrapper);\n  }\n\n  /**\n   * Updates the state of keyboard navigation and the position of the cursor\n   * based on workspace events.\n   *\n   * @param e The Blockly event to process.\n   */\n  workspaceChangeListener(e: Blockly.Events.Abstract) {\n    if (!e.workspaceId) {\n      return;\n    }\n    const workspace = Blockly.Workspace.getById(\n      e.workspaceId,\n    ) as Blockly.WorkspaceSvg;\n    if (!workspace || !workspace.keyboardAccessibilityMode) {\n      return;\n    }\n    if (e.type === Blockly.Events.BLOCK_CHANGE) {\n      if ((e as Blockly.Events.BlockChange).element === 'mutation') {\n        this.handleBlockMutation(workspace, e as Blockly.Events.BlockChange);\n      }\n    }\n  }\n\n  /**\n   * Updates the state of keyboard navigation and the position of the cursor\n   * based on events emitted from the flyout's workspace.\n   *\n   * @param e The Blockly event to process.\n   */\n  flyoutChangeListener(e: Blockly.Events.Abstract) {\n    if (!e.workspaceId) {\n      return;\n    }\n    const flyoutWorkspace = Blockly.Workspace.getById(\n      e.workspaceId,\n    ) as Blockly.WorkspaceSvg | null;\n    const mainWorkspace = flyoutWorkspace?.targetWorkspace;\n    if (!mainWorkspace) {\n      return;\n    }\n    const flyout = mainWorkspace.getFlyout();\n    if (!flyout) {\n      return;\n    }\n\n    // This is called for simple toolboxes and for toolboxes that have a flyout\n    // that does not close. Autoclosing flyouts close before we need to focus\n    // the cursor on the block that was clicked.\n    if (\n      mainWorkspace &&\n      mainWorkspace.keyboardAccessibilityMode &&\n      !flyout.autoClose\n    ) {\n      if (\n        e.type === Blockly.Events.CLICK &&\n        (e as Blockly.Events.Click).targetType === 'block'\n      ) {\n        const {blockId} = e as Blockly.Events.Click;\n        if (blockId) {\n          const block = flyoutWorkspace.getBlockById(blockId);\n          if (block) {\n            this.handleBlockClickInFlyout(mainWorkspace, block);\n          }\n        }\n      } else if (e.type === Blockly.Events.SELECTED) {\n        const {newElementId} = e as Blockly.Events.Selected;\n        if (newElementId) {\n          const block = flyoutWorkspace.getBlockById(newElementId);\n          if (block) {\n            this.handleBlockClickInFlyout(mainWorkspace, block);\n          }\n        }\n      }\n    } else if (\n      e.type === Blockly.Events.BLOCK_CREATE &&\n      this.getState() === Constants.STATE.FLYOUT\n    ) {\n      // When variables are created, that recreates the flyout contents, leaving the\n      // cursor in an invalid state.\n      this.defaultFlyoutCursorIfNeeded(mainWorkspace);\n    }\n  }\n\n  private isFlyoutItemDisposed(\n    node: Blockly.IFocusableNode,\n    sourceBlock: Blockly.BlockSvg | null,\n  ) {\n    if (sourceBlock?.disposed) {\n      return true;\n    }\n    if (node instanceof Blockly.FlyoutButton) {\n      return node.getSvgRoot().parentNode === null;\n    }\n    return false;\n  }\n\n  /**\n   * Moves the cursor to the block level when the block the cursor is on\n   * mutates.\n   *\n   * @param workspace The workspace the cursor belongs\n   *     to.\n   * @param e The Blockly event to process.\n   */\n  handleBlockMutation(\n    workspace: Blockly.WorkspaceSvg,\n    e: Blockly.Events.BlockChange,\n  ) {\n    const mutatedBlockId = e.blockId;\n    const cursor = workspace.getCursor();\n    const block = cursor?.getSourceBlock();\n    if (block && block.id === mutatedBlockId) {\n      cursor?.setCurNode(block);\n    }\n  }\n\n  /**\n   * Handles when a user clicks on a block in the flyout by moving the cursor\n   * to that stack of blocks and setting the state of navigation to the flyout.\n   *\n   * @param mainWorkspace The workspace the user clicked on.\n   * @param block The block the user clicked on.\n   */\n  handleBlockClickInFlyout(\n    mainWorkspace: Blockly.WorkspaceSvg,\n    block: Blockly.BlockSvg,\n  ) {\n    if (!block) {\n      return;\n    }\n    const curNodeBlock = block.isShadow() ? block : block.getParent();\n    if (curNodeBlock) {\n      this.getFlyoutCursor(mainWorkspace)?.setCurNode(curNodeBlock);\n    }\n    const flyout = mainWorkspace.getFlyout();\n    if (flyout) {\n      Blockly.getFocusManager().focusTree(flyout.getWorkspace());\n    }\n  }\n\n  /**\n   * Move the flyout cursor to the preferred end if unset (as it is initially despite\n   * the types) or on a disposed item.\n   *\n   * @param workspace The workspace.\n   * @param prefer The preferred default position.\n   * @return true if the cursor location was defaulted.\n   */\n  defaultFlyoutCursorIfNeeded(\n    workspace: Blockly.WorkspaceSvg,\n    prefer: 'first' | 'last' = 'first',\n  ) {\n    const flyout = workspace.getFlyout();\n    if (!flyout) return false;\n    const flyoutCursor = this.getFlyoutCursor(workspace);\n    if (!flyoutCursor) return false;\n\n    const curNode = flyoutCursor.getCurNode();\n    const sourceBlock = flyoutCursor.getSourceBlock();\n    // If the current node is a child of the flyout, nothing needs to be done.\n    if (\n      curNode &&\n      curNode !== flyout.getWorkspace() &&\n      curNode.getFocusableTree() === flyout.getWorkspace() &&\n      !this.isFlyoutItemDisposed(curNode, sourceBlock)\n    ) {\n      return false;\n    }\n\n    const flyoutContents = flyout.getContents();\n    const defaultFlyoutItem =\n      prefer === 'first'\n        ? flyoutContents[0]\n        : flyoutContents[flyoutContents.length - 1];\n    if (!defaultFlyoutItem) return false;\n    const defaultFlyoutItemElement = defaultFlyoutItem.getElement();\n    flyoutCursor.setCurNode(defaultFlyoutItemElement);\n    return true;\n  }\n\n  /**\n   * Sets the cursor location when focusing the workspace.\n   * Tries the following, in order, stopping after the first success:\n   *  - Resume editing by returning the cursor to its previous location, if valid.\n   *  - Move the cursor to the top connection point on on the first top block.\n   *  - Move the cursor to the default location on the workspace.\n   *\n   * @param workspace The main Blockly workspace.\n   * @param prefer The preferred default position.\n   * @return true if the cursor location was defaulted.\n   */\n  defaultWorkspaceCursorPositionIfNeeded(\n    workspace: Blockly.WorkspaceSvg,\n    prefer: 'first' | 'last' = 'first',\n  ) {\n    const topBlocks = workspace.getTopBlocks(true);\n    const cursor = workspace.getCursor();\n    if (!cursor) {\n      return;\n    }\n    const disposed = cursor.getSourceBlock()?.disposed;\n    if (cursor.getCurNode() && !disposed) {\n      // Retain the cursor's previous position since it's set, but only if not\n      // disposed (which can happen when blocks are reloaded).\n      return false;\n    }\n    if (topBlocks.length > 0) {\n      cursor.setCurNode(\n        topBlocks[prefer === 'first' ? 0 : topBlocks.length - 1],\n      );\n    } else {\n      cursor.setCurNode(workspace);\n    }\n    return true;\n  }\n\n  /**\n   * Gets the cursor on the flyout's workspace.\n   *\n   * @param workspace The main workspace the flyout is on.\n   * @returns The flyout's cursor or null if no flyout exists.\n   */\n  getFlyoutCursor(workspace: Blockly.WorkspaceSvg): Blockly.LineCursor | null {\n    const flyout = workspace.getFlyout();\n    const cursor = flyout ? flyout.getWorkspace().getCursor() : null;\n\n    return cursor;\n  }\n\n  /**\n   * Tries to intelligently connect the blocks or connections\n   * represented by the given nodes, based on node types and locations.\n   *\n   * @param stationaryNode The first node to connect.\n   * @param movingBlock The block we're moving.\n   * @returns True if the key was handled; false if something went\n   *     wrong.\n   */\n  findInsertStartPoint(\n    stationaryNode: Blockly.IFocusableNode,\n    movingBlock: Blockly.BlockSvg,\n  ): Blockly.RenderedConnection | null {\n    const movingHasOutput = !!movingBlock.outputConnection;\n\n    if (stationaryNode instanceof Blockly.Field) {\n      // Can't connect a block to a field, so try going up to the source block.\n      const sourceBlock = stationaryNode.getSourceBlock() as Blockly.BlockSvg;\n      if (!sourceBlock) return null;\n      return this.findInsertStartPoint(sourceBlock, movingBlock);\n    } else if (stationaryNode instanceof Blockly.RenderedConnection) {\n      // Move to the block if we're trying to insert a statement block into\n      // a value connection.\n      if (\n        !movingHasOutput &&\n        stationaryNode.type === Blockly.ConnectionType.INPUT_VALUE\n      ) {\n        const sourceBlock = stationaryNode.getSourceBlock();\n        if (!sourceBlock) return null;\n        return this.findInsertStartPoint(sourceBlock, movingBlock);\n      }\n\n      // Connect the moving block to the stationary connection using\n      // the most plausible connection on the moving block.\n      return stationaryNode;\n    } else if (stationaryNode instanceof Blockly.WorkspaceSvg) {\n      return null;\n    } else if (stationaryNode instanceof Blockly.BlockSvg) {\n      // 1. Connect blocks to first compatible input\n      const inputType = movingHasOutput\n        ? Blockly.inputs.inputTypes.VALUE\n        : Blockly.inputs.inputTypes.STATEMENT;\n      const compatibleInputs = stationaryNode.inputList.filter(\n        (input) => input.type === inputType,\n      );\n      const input = compatibleInputs.length > 0 ? compatibleInputs[0] : null;\n      let connection = input?.connection;\n      if (connection) {\n        if (inputType === Blockly.inputs.inputTypes.STATEMENT) {\n          while (connection.targetBlock()?.nextConnection) {\n            // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n            connection = connection.targetBlock()!.nextConnection!;\n          }\n        }\n        return connection as Blockly.RenderedConnection;\n      }\n\n      // 2. Connect statement blocks to next connection.\n      if (stationaryNode.nextConnection && !movingHasOutput) {\n        return stationaryNode.nextConnection;\n      }\n\n      // 3. Output connection. This will wrap around or displace.\n      if (stationaryNode.outputConnection) {\n        // Try to wrap.\n        const target = stationaryNode.outputConnection.targetConnection;\n        if (movingHasOutput && target) {\n          return this.findInsertStartPoint(target, movingBlock);\n        } else if (!movingHasOutput) {\n          // Move to parent if we're trying to insert a statement block.\n          const parent = stationaryNode.getParent();\n          if (!parent) return null;\n          return this.findInsertStartPoint(parent, movingBlock);\n        }\n        return stationaryNode.outputConnection;\n      }\n    }\n    this.warn(`Unexpected case in findInsertStartPoint ${stationaryNode}.`);\n    return null;\n  }\n\n  /**\n   * Tries to intelligently connect the blocks or connections\n   * represented by the given nodes, based on node types and locations.\n   *\n   * @param stationaryNode The first node to connect.\n   * @param movingBlock The block we're moving.\n   * @returns True if the connection was successful, false otherwise.\n   */\n  tryToConnectBlock(\n    stationaryNode: Blockly.IFocusableNode,\n    movingBlock: Blockly.BlockSvg,\n  ): boolean {\n    const destConnection = this.findInsertStartPoint(\n      stationaryNode,\n      movingBlock,\n    );\n    if (!destConnection) return false;\n    return this.insertBlock(movingBlock, destConnection);\n  }\n\n  /**\n   * Disconnects the child block from its parent block. No-op if the two given\n   * connections are unrelated.\n   *\n   * @param movingConnection The connection that is being moved.\n   * @param destConnection The connection to be moved to.\n   */\n  disconnectChild(\n    movingConnection: Blockly.RenderedConnection,\n    destConnection: Blockly.RenderedConnection,\n  ) {\n    const movingBlock = movingConnection.getSourceBlock();\n    const destBlock = destConnection.getSourceBlock();\n    let inferiorConnection;\n\n    if (movingBlock.getRootBlock() === destBlock.getRootBlock()) {\n      if (movingBlock.getDescendants(false).includes(destBlock)) {\n        inferiorConnection = this.getInferiorConnection(destConnection);\n        if (inferiorConnection) {\n          inferiorConnection.disconnect();\n        }\n      } else {\n        inferiorConnection = this.getInferiorConnection(movingConnection);\n        if (inferiorConnection) {\n          inferiorConnection.disconnect();\n        }\n      }\n    }\n  }\n\n  /**\n   * Tries to connect the  given connections.\n   *\n   * If the given connections are not compatible try finding compatible\n   * connections on the source blocks of the given connections.\n   *\n   * @param movingConnection The connection that is being moved.\n   * @param destConnection The connection to be moved to.\n   * @returns True if the two connections or their target connections\n   *     were connected, false otherwise.\n   */\n  connect(\n    movingConnection: Blockly.RenderedConnection | null,\n    destConnection: Blockly.RenderedConnection | null,\n  ): boolean {\n    if (!movingConnection || !destConnection) {\n      return false;\n    }\n\n    const movingInferior = this.getInferiorConnection(movingConnection);\n    const destSuperior = this.getSuperiorConnection(destConnection);\n\n    const movingSuperior = this.getSuperiorConnection(movingConnection);\n    const destInferior = this.getInferiorConnection(destConnection);\n\n    if (\n      movingInferior &&\n      destSuperior &&\n      this.moveAndConnect(movingInferior, destSuperior)\n    ) {\n      return true;\n      // Try swapping the inferior and superior connections on the blocks.\n    } else if (\n      movingSuperior &&\n      destInferior &&\n      this.moveAndConnect(movingSuperior, destInferior)\n    ) {\n      return true;\n    } else if (this.moveAndConnect(movingConnection, destConnection)) {\n      return true;\n    } else {\n      const checker = movingConnection.getConnectionChecker();\n      const reason = checker.canConnectWithReason(\n        movingConnection,\n        destConnection,\n        false,\n      );\n      this.warn(\n        'Connection failed with error: ' +\n          checker.getErrorMessage(reason, movingConnection, destConnection),\n      );\n      return false;\n    }\n  }\n\n  /**\n   * Finds the inferior connection on the source block if the given connection\n   * is superior.\n   *\n   * @param connection The connection trying to be connected.\n   * @returns The inferior connection or null if none exists.\n   */\n  getInferiorConnection(\n    connection: Blockly.RenderedConnection | null,\n  ): Blockly.RenderedConnection | null {\n    if (!connection) {\n      return null;\n    }\n    const block = connection.getSourceBlock() as Blockly.BlockSvg;\n    if (!connection.isSuperior()) {\n      return connection;\n    } else if (block.previousConnection) {\n      return block.previousConnection;\n    } else if (block.outputConnection) {\n      return block.outputConnection;\n    } else {\n      return null;\n    }\n  }\n\n  /**\n   * Finds a superior connection on the source block if the given connection is\n   * inferior.\n   *\n   * @param connection The connection trying to be connected.\n   * @returns The superior connection or null if none exists.\n   */\n  getSuperiorConnection(\n    connection: Blockly.RenderedConnection | null,\n  ): Blockly.RenderedConnection | null {\n    if (!connection) {\n      return null;\n    }\n    if (connection.isSuperior()) {\n      return connection;\n    } else if (connection.targetConnection) {\n      return connection.targetConnection;\n    }\n    return null;\n  }\n\n  /**\n   * Moves the moving connection to the target connection and connects them.\n   *\n   * @param movingConnection The connection that is being moved.\n   * @param destConnection The connection to be moved to.\n   * @returns True if the connections were connected, false otherwise.\n   */\n  moveAndConnect(\n    movingConnection: Blockly.RenderedConnection | null,\n    destConnection: Blockly.RenderedConnection | null,\n  ): boolean {\n    if (!movingConnection || !destConnection) {\n      return false;\n    }\n    const movingBlock = movingConnection.getSourceBlock();\n    const checker = movingConnection.getConnectionChecker();\n\n    if (\n      checker.canConnect(movingConnection, destConnection, false) &&\n      !destConnection.getSourceBlock().isShadow()\n    ) {\n      this.disconnectChild(movingConnection, destConnection);\n\n      // Position the root block near the connection so it does not move the\n      // other block when they are connected.\n      if (!destConnection.isSuperior()) {\n        const rootBlock = movingBlock.getRootBlock();\n\n        const originalOffsetToTarget = {\n          x: destConnection.x - movingConnection.x,\n          y: destConnection.y - movingConnection.y,\n        };\n        const originalOffsetInBlock = movingConnection\n          .getOffsetInBlock()\n          .clone();\n        rootBlock.positionNearConnection(\n          movingConnection,\n          originalOffsetToTarget,\n          originalOffsetInBlock,\n        );\n      }\n      destConnection.connect(movingConnection);\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Tries to connect the given block to the destination connection, making an\n   * intelligent guess about which connection to use on the moving block.\n   *\n   * @param block The block to move.\n   * @param destConnection The connection to\n   *     connect to.\n   * @returns Whether the connection was successful.\n   */\n  insertBlock(\n    block: Blockly.BlockSvg,\n    destConnection: Blockly.RenderedConnection,\n  ): boolean {\n    switch (destConnection.type) {\n      case Blockly.PREVIOUS_STATEMENT:\n        if (this.connect(block.nextConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.NEXT_STATEMENT:\n        if (this.connect(block.previousConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.INPUT_VALUE:\n        if (this.connect(block.outputConnection, destConnection)) {\n          return true;\n        }\n        break;\n      case Blockly.OUTPUT_VALUE:\n        for (let i = 0; i < block.inputList.length; i++) {\n          const inputConnection = block.inputList[i].connection;\n          if (\n            inputConnection &&\n            inputConnection.type === Blockly.INPUT_VALUE &&\n            this.connect(\n              inputConnection as Blockly.RenderedConnection,\n              destConnection,\n            )\n          ) {\n            return true;\n          }\n        }\n        // If there are no input values pass the output and destination\n        // connections to connect_ to find a way to connect the two.\n        if (\n          block.outputConnection &&\n          this.connect(block.outputConnection, destConnection)\n        ) {\n          return true;\n        }\n        break;\n    }\n    this.warn('This block can not be inserted at the marked location.');\n    return false;\n  }\n\n  /**\n   * Enables accessibility mode.\n   *\n   * @param workspace The workspace to enable keyboard\n   *     accessibility mode on.\n   */\n  enableKeyboardAccessibility(workspace: Blockly.WorkspaceSvg) {\n    if (\n      this.workspaces.includes(workspace) &&\n      !workspace.keyboardAccessibilityMode\n    ) {\n      workspace.keyboardAccessibilityMode = true;\n    }\n  }\n\n  /**\n   * Disables accessibility mode.\n   *\n   * @param workspace The workspace to disable keyboard\n   *     accessibility mode on.\n   */\n  disableKeyboardAccessibility(workspace: Blockly.WorkspaceSvg) {\n    if (\n      this.workspaces.includes(workspace) &&\n      workspace.keyboardAccessibilityMode\n    ) {\n      workspace.keyboardAccessibilityMode = false;\n    }\n  }\n\n  /**\n   * Navigation log handler. If loggingCallback is defined, use it.\n   * Otherwise just log to the console.log.\n   *\n   * @param msg The message to log.\n   */\n  log(msg: string) {\n    console.log(msg);\n  }\n\n  /**\n   * Navigation warning handler. If loggingCallback is defined, use it.\n   * Otherwise call console.warn.\n   *\n   * @param msg The warning message.\n   */\n  warn(msg: string) {\n    console.warn(msg);\n  }\n\n  /**\n   * Navigation error handler. If loggingCallback is defined, use it.\n   * Otherwise call console.error.\n   *\n   * @param msg The error message.\n   */\n  error(msg: string) {\n    console.error(msg);\n  }\n\n  /**\n   * Save the current cursor location and open the toolbox or flyout\n   * to select and insert a block.\n   *\n   * @param workspace The active workspace.\n   */\n  openToolboxOrFlyout(workspace: Blockly.WorkspaceSvg) {\n    const toolbox = workspace.getToolbox();\n    const flyout = workspace.getFlyout();\n    if (toolbox) {\n      Blockly.getFocusManager().focusTree(toolbox);\n    } else if (flyout) {\n      Blockly.getFocusManager().focusTree(flyout.getWorkspace());\n    }\n  }\n\n  /**\n   * Pastes the copied block to the marked location if possible or\n   * onto the workspace otherwise.\n   *\n   * @param copyData The data to paste into the workspace.\n   * @param workspace The workspace to paste the data into.\n   * @returns True if the paste was sucessful, false otherwise.\n   */\n  paste(copyData: Blockly.ICopyData, workspace: Blockly.WorkspaceSvg): boolean {\n    // Do this before clipoard.paste due to cursor/focus workaround in getCurNode.\n    const targetNode = workspace.getCursor()?.getCurNode();\n\n    Blockly.Events.setGroup(true);\n    const block = Blockly.clipboard.paste(\n      copyData,\n      workspace,\n    ) as Blockly.BlockSvg;\n    if (block) {\n      if (targetNode) {\n        this.tryToConnectBlock(targetNode, block);\n      }\n      return true;\n    }\n    Blockly.Events.setGroup(false);\n    return false;\n  }\n\n  /**\n   * Determines whether keyboard navigation should be allowed based on the\n   * current state of the workspace.\n   *\n   * A return value of 'true' generally indicates that either the workspace,\n   * toolbox or flyout has enabled keyboard navigation and is currently in a\n   * state (e.g. focus) that can support keyboard navigation.\n   *\n   * @param workspace the workspace in which keyboard navigation may be allowed.\n   * @returns whether keyboard navigation is currently allowed.\n   */\n  canCurrentlyNavigate(workspace: Blockly.WorkspaceSvg) {\n    // Only the main/root workspace has the accessibility mode bit set; for\n    // nested workspaces (mutators or flyouts) we need to walk up the tree.\n    // Default to the root workspace if present. Flyouts don't consider\n    // their workspaces to have a root workspace/be a nested child, so fall\n    // back to checking the target workspace's root (`.targetWorkspace` only\n    // exists on flyout workspaces) and then fall back to the target/main\n    // workspace itself.\n    const accessibilityMode = (\n      workspace.getRootWorkspace() ??\n      workspace.targetWorkspace?.getRootWorkspace() ??\n      workspace.targetWorkspace ??\n      workspace\n    ).keyboardAccessibilityMode;\n    return !!accessibilityMode && this.getState() !== Constants.STATE.NOWHERE;\n  }\n\n  /**\n   * Determines whether the provided workspace is currently keyboard navigable\n   * and editable.\n   *\n   * For the navigability criteria, see canCurrentlyKeyboardNavigate.\n   *\n   * @param workspace the workspace in which keyboard editing may be allowed.\n   * @returns whether keyboard navigation and editing is currently allowed.\n   */\n  canCurrentlyEdit(workspace: Blockly.WorkspaceSvg) {\n    return this.canCurrentlyNavigate(workspace) && !workspace.isReadOnly();\n  }\n\n  /**\n   * Removes the change listeners on all registered workspaces.\n   */\n  dispose() {\n    for (const workspace of this.workspaces) {\n      this.removeWorkspace(workspace);\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport * as Constants from './constants';\nimport {Msg, ShortcutRegistry} from 'blockly/core';\nimport {\n  getLongActionShortcutsAsKeys,\n  upperCaseFirst,\n} from './shortcut_formatting';\nimport {clearHelpHint} from './hints';\n\n/**\n * Class for handling the shortcuts dialog.\n */\nexport class ShortcutDialog {\n  outputDiv: HTMLElement | null;\n  modalContainer: HTMLElement | null;\n  shortcutDialog: HTMLDialogElement | null;\n  open: boolean;\n  closeButton: HTMLElement | null;\n  /**\n   * Constructor for a dialog that displays available keyboard shortcuts.\n   */\n  constructor() {\n    // For testing purposes, this assumes that the page has a\n    // div named 'shortcuts'.\n    this.outputDiv = document.getElementById('shortcuts');\n\n    this.open = false;\n    this.modalContainer = null;\n    this.shortcutDialog = null;\n    this.closeButton = null;\n  }\n\n  getPlatform() {\n    const {platform, userAgent} = navigator;\n    if (platform.startsWith('Win')) {\n      return Msg['WINDOWS'];\n    } else if (platform.startsWith('Mac')) {\n      return Msg['MAC_OS'];\n    } else if (/\\bCrOS\\b/.test(userAgent)) {\n      // Order is important because platform matches the Linux case below.\n      return Msg['CHROME_OS'];\n    } else if (platform.includes('Linux')) {\n      return Msg['LINUX'];\n    } else {\n      return Msg['UNKNOWN'];\n    }\n  }\n\n  /**\n   * Update the modifier key to the user's specific platform.\n   */\n  updatePlatformName() {\n    const platform = this.getPlatform();\n    const platformEl = this.outputDiv\n      ? this.outputDiv.querySelector('.platform')\n      : null;\n    if (platformEl) {\n      platformEl.textContent = platform;\n    }\n  }\n\n  toggle(workspace: Blockly.WorkspaceSvg) {\n    clearHelpHint(workspace);\n    this.toggleInternal();\n  }\n\n  toggleInternal() {\n    if (this.modalContainer && this.shortcutDialog) {\n      // Use built in dialog methods.\n      if (this.shortcutDialog.hasAttribute('open')) {\n        this.shortcutDialog.close();\n      } else {\n        this.shortcutDialog.showModal();\n      }\n    }\n  }\n\n  /**\n   * Munges a shortcut name into human readable text.\n   *\n   * @param shortcutName Shortcut name to convert.\n   * @returns A title case version of the name.\n   */\n  getReadableShortcutName(shortcutName: string) {\n    return upperCaseFirst(shortcutName.replace(/_/gi, ' '));\n  }\n\n  /**\n   * List all currently registered shortcuts as a table.\n   */\n  createModalContent() {\n    let modalContents = `<div class=\"modal-container\">\n      <dialog class=\"shortcut-modal\">\n        <div class=\"shortcut-container\" tabindex=\"0\">\n          <div class=\"header\">\n            <button class=\"close-modal\">\n              <span class=\"material-symbols-outlined\">close</span>\n            </button>\n            <h1>Keyboard shortcuts  <span class=\"platform\">Windows</span></h1>\n          </div>\n          <div class=\"shortcut-tables\">`;\n\n    // Display shortcuts by their categories.\n    for (const [key, categoryShortcuts] of Object.entries(\n      Constants.SHORTCUT_CATEGORIES,\n    )) {\n      modalContents += `\n        <table class=\"shortcut-table\">\n          <tbody>\n          <tr class=\"category\"><th colspan=\"3\"><h2>${key}</h2></th></tr>\n          <tr>\n          `;\n\n      for (const keyboardShortcut of categoryShortcuts) {\n        modalContents += `\n              <td>${this.getReadableShortcutName(keyboardShortcut)}</td>\n              <td>${this.actionShortcutsToHTML(keyboardShortcut)}</td>\n              </tr>`;\n      }\n      modalContents += '</tr></tbody></table>';\n    }\n    if (this.outputDiv) {\n      this.outputDiv.innerHTML =\n        modalContents +\n        `</div>\n      </dialog>\n    </div>`;\n      this.modalContainer = this.outputDiv.querySelector('.modal-container');\n      this.shortcutDialog = this.outputDiv.querySelector('.shortcut-modal');\n      this.closeButton = this.outputDiv.querySelector('.close-modal');\n      this.updatePlatformName();\n      // Can we also intercept the Esc key to dismiss.\n      if (this.closeButton) {\n        this.closeButton.addEventListener('click', (e) => {\n          this.toggleInternal();\n        });\n      }\n    }\n  }\n\n  private actionShortcutsToHTML(action: string) {\n    const shortcuts = getLongActionShortcutsAsKeys(action);\n    return shortcuts.map((keys) => this.actionShortcutToHTML(keys)).join(' / ');\n  }\n\n  private actionShortcutToHTML(keys: string[]) {\n    const separator = navigator.platform.startsWith('Mac') ? '' : ' + ';\n    return [\n      `<span class=\"shortcut-combo\">`,\n      ...keys.map((key, index) => {\n        return `<span class=\"key\">${key}</span>${index < keys.length - 1 ? separator : ''}`;\n      }),\n      `</span>`,\n    ].join('');\n  }\n\n  /**\n   * Registers an action to list shortcuts with the shortcut registry.\n   */\n  install() {\n    /** List all of the currently registered shortcuts. */\n    const announceShortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.LIST_SHORTCUTS,\n      callback: (workspace) => {\n        this.toggle(workspace);\n        return true;\n      },\n      keyCodes: [Blockly.utils.KeyCodes.SLASH],\n    };\n    ShortcutRegistry.registry.register(announceShortcut);\n  }\n\n  /**\n   * Unregisters the action to list shortcuts.\n   */\n  uninstall() {\n    ShortcutRegistry.registry.unregister(\n      Constants.SHORTCUT_NAMES.LIST_SHORTCUTS,\n    );\n  }\n}\n\n/**\n * Register classes used by the shortcuts modal\n * Alt: plugin exports a register() function that updates the registry\n */\nBlockly.Css.register(`\n:root {\n  --divider-border-color: #eee;\n  --key-border-color: #ccc;\n  --shortcut-modal-border-color: #9aa0a6;\n}\n\n.shortcut-modal {\n  border: 1px solid var(--shortcut-modal-border-color);\n  border-radius: 12px;\n  box-shadow: 6px 6px 32px rgba(0,0,0,.5);\n  flex-direction: column;\n  gap: 12px;\n  margin: auto;\n  max-height: 82vh;\n  max-width: calc(100% - 10em);\n  padding: 24px 12px 24px 32px;\n  position: relative;\n  z-index: 99;\n}\n\n.shortcut-modal[open] {\n  display: flex;\n}\n\n.shortcut-modal .close-modal {\n  border: 0;\n  background: transparent;\n  float: inline-end;\n  margin: 0 0 0 0;\n  position: absolute;\n  top: 16px;\n  right: 24px;\n}\n\n.shortcut-modal h1 {\n  font-weight: 600;\n  font-size: 1.2em;\n}\n\n.shortcut-modal:before {\n  background: radial-gradient(rgba(244, 244, 244, 0.43), rgba(75, 75, 75, 0.51));\n  align-items: center;\n  display: block;\n  font-family: Roboto;\n  height: 100%;\n  justify-content: center;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100%;\n}\n\n.shortcut-tables {\n  display: grid;\n  align-items: start;\n  grid-template-columns: 1fr;\n  row-gap: 1em;\n  column-gap: 2em;\n}\n\n@media (min-width: 950px) {\n  .shortcut-tables {\n    grid-template-columns: 1fr 1fr\n  }\n}\n\n@media (min-width: 1360px) {\n  .shortcut-tables {\n    grid-template-columns: 1fr 1fr 1fr\n  }\n}\n\n.shortcut-table {\n  border-collapse: collapse;\n  font-family: Roboto;\n  font-size: .9em;\n}\n\n.shortcut-table th {\n  padding-inline-end: 0.5em;\n  text-align: left;\n  text-wrap: nowrap;\n  vertical-align: baseline;\n}\n\n.shortcut-table td:first-child {\n  text-wrap: auto;\n  width: 40%;\n}\n\n.shortcut-table tr:has(+ .category) {\n  --divider-border-color: transparent;\n  margin-end: 1em;\n}\n\n.shortcut-table tr:not(.category, :last-child) {\n  border-bottom: 1px solid var(--divider-border-color);\n}\n\n.shortcut-table td {\n  padding: 0.2em 1em 0.3em 0;\n  text-wrap: nowrap;\n}\n\n.shortcut-table h2 {\n  border-bottom: 1px solid #999;\n  font-size: 1em;\n  padding-block-end: 0.5em;\n}\n\n.shortcut-table .key {\n  border: 1px solid var(--key-border-color);\n  border-radius: 8px;\n  display: inline-block;\n  margin: 0 4px;\n  min-width: 2em;\n  padding: .3em .5em;\n  text-align: center;\n}\n\n.shortcut-table .separator {\n  color: gray;\n  display: inline-block;\n  padding: 0 0.5em;\n}\n\n.shortcut-container {\n  font-size: 0.95em;\n  overflow: auto;\n  padding: 0.5em;\n}\n\n.shortcut-combo {\n  display: inline-block;\n  padding: 0.25em 0;\n  text-wrap: nowrap;\n}\n\n`);\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  ShortcutRegistry,\n  utils as BlocklyUtils,\n  keyboardNavigationController,\n} from 'blockly';\nimport * as Constants from '../constants';\nimport type {WorkspaceSvg} from 'blockly';\nimport {Navigation} from 'src/navigation';\n\nconst KeyCodes = BlocklyUtils.KeyCodes;\nconst createSerializedKey = ShortcutRegistry.registry.createSerializedKey.bind(\n  ShortcutRegistry.registry,\n);\n\n/**\n * Logic for free movement of the cursor on the workspace with keyboard\n * shortcuts.\n */\nexport class WorkspaceMovement {\n  constructor(private navigation: Navigation) {}\n\n  private shortcuts: ShortcutRegistry.KeyboardShortcut[] = [\n    /** Move the cursor on the workspace to the left. */\n    {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_LEFT,\n      preconditionFn: (workspace) =>\n        this.navigation.canCurrentlyEdit(workspace),\n      callback: (workspace) => this.moveWSCursor(workspace, -1, 0),\n      keyCodes: [createSerializedKey(KeyCodes.A, [KeyCodes.SHIFT])],\n    },\n    /** Move the cursor on the workspace to the right. */\n    {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_RIGHT,\n      preconditionFn: (workspace) =>\n        this.navigation.canCurrentlyEdit(workspace),\n      callback: (workspace) => this.moveWSCursor(workspace, 1, 0),\n      keyCodes: [createSerializedKey(KeyCodes.D, [KeyCodes.SHIFT])],\n    },\n    /** Move the cursor on the workspace up. */\n    {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_UP,\n      preconditionFn: (workspace) =>\n        this.navigation.canCurrentlyEdit(workspace),\n      callback: (workspace) => this.moveWSCursor(workspace, 0, -1),\n      keyCodes: [createSerializedKey(KeyCodes.W, [KeyCodes.SHIFT])],\n    },\n\n    /** Move the cursor on the workspace down. */\n    {\n      name: Constants.SHORTCUT_NAMES.MOVE_WS_CURSOR_DOWN,\n      preconditionFn: (workspace) =>\n        this.navigation.canCurrentlyEdit(workspace),\n      callback: (workspace) => this.moveWSCursor(workspace, 0, 1),\n      keyCodes: [createSerializedKey(KeyCodes.S, [KeyCodes.SHIFT])],\n    },\n\n    /** Move the cursor to the workspace. */\n    {\n      name: Constants.SHORTCUT_NAMES.CREATE_WS_CURSOR,\n      preconditionFn: (workspace) => {\n        return true;\n      },\n      callback: (workspace) => {\n        const targetWorkspace = workspace.isFlyout\n          ? workspace.targetWorkspace\n          : workspace;\n        if (!targetWorkspace) return false;\n        keyboardNavigationController.setIsActive(true);\n        return this.createWSCursor(targetWorkspace);\n      },\n      keyCodes: [KeyCodes.W],\n    },\n  ];\n\n  /**\n   * Install the shortcuts.\n   */\n  install() {\n    for (const shortcut of this.shortcuts) {\n      ShortcutRegistry.registry.register(shortcut);\n    }\n  }\n\n  /**\n   * Uninstall the shortcuts.\n   */\n  uninstall() {\n    for (const shortcut of this.shortcuts) {\n      ShortcutRegistry.registry.unregister(shortcut.name);\n    }\n  }\n\n  /**\n   * Moves the workspace cursor in the given direction.\n   *\n   * @param workspace The workspace the cursor is on.\n   * @param xDirection -1 to move cursor left. 1 to move cursor right.\n   * @param yDirection -1 to move cursor up. 1 to move cursor down.\n   * @returns True if the current node is a workspace, false\n   *     otherwise.\n   */\n  moveWSCursor(\n    workspace: WorkspaceSvg,\n    xDirection: number,\n    yDirection: number,\n  ): boolean {\n    return false;\n  }\n\n  /**\n   * Moves the cursor to the workspace near the origin.\n   *\n   * @param workspace The workspace the cursor is on.\n   */\n  createWSCursor(workspace: WorkspaceSvg) {\n    const cursor = workspace.getCursor();\n\n    if (!cursor) return false;\n\n    cursor.setCurNode(workspace);\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  ShortcutRegistry,\n  utils as BlocklyUtils,\n  Field,\n  keyboardNavigationController,\n} from 'blockly/core';\n\nimport type {Toolbox, WorkspaceSvg} from 'blockly/core';\n\nimport * as Blockly from 'blockly/core';\nimport * as Constants from '../constants';\nimport type {Navigation} from '../navigation';\n\nconst KeyCodes = BlocklyUtils.KeyCodes;\n\n/**\n * Class for registering shortcuts for navigating the workspace with arrow keys.\n */\nexport class ArrowNavigation {\n  constructor(private navigation: Navigation) {}\n\n  /**\n   * Gives the cursor to the field to handle if the cursor is on a field.\n   *\n   * @param workspace The workspace to check.\n   * @param shortcut The shortcut\n   *     to give to the field.\n   * @returns True if the shortcut was handled by the field, false\n   *     otherwise.\n   */\n  fieldShortcutHandler(\n    workspace: WorkspaceSvg,\n    shortcut: ShortcutRegistry.KeyboardShortcut,\n  ): boolean {\n    const cursor = workspace.getCursor();\n    if (!cursor || !cursor.getCurNode()) {\n      return false;\n    }\n    const curNode = cursor.getCurNode();\n    if (curNode instanceof Field) {\n      return curNode.onShortcut(shortcut);\n    }\n    return false;\n  }\n\n  /**\n   * Adds all arrow key navigation shortcuts to the registry.\n   */\n  install() {\n    const navigateIn = (\n      workspace: WorkspaceSvg,\n      e: Event,\n      shortcut: ShortcutRegistry.KeyboardShortcut,\n    ): boolean => {\n      const toolbox = workspace.getToolbox() as Toolbox;\n      const flyout = workspace.isFlyout\n        ? workspace.targetWorkspace?.getFlyout()\n        : workspace.getFlyout();\n      let isHandled = false;\n      switch (this.navigation.getState()) {\n        case Constants.STATE.WORKSPACE:\n          isHandled = this.fieldShortcutHandler(workspace, shortcut);\n          if (!isHandled && workspace) {\n            if (\n              !this.navigation.defaultWorkspaceCursorPositionIfNeeded(workspace)\n            ) {\n              workspace.getCursor()?.in();\n            }\n            isHandled = true;\n          }\n          return isHandled;\n        case Constants.STATE.TOOLBOX:\n          // @ts-expect-error private method\n          isHandled = toolbox && toolbox.selectChild();\n          if (!isHandled && flyout) {\n            this.navigation.defaultFlyoutCursorIfNeeded(workspace);\n          }\n          return true;\n        default:\n          return false;\n      }\n    };\n\n    const navigateOut = (\n      workspace: WorkspaceSvg,\n      e: Event,\n      shortcut: ShortcutRegistry.KeyboardShortcut,\n    ): boolean => {\n      const toolbox = workspace.isFlyout\n        ? workspace.targetWorkspace?.getToolbox()\n        : workspace.getToolbox();\n      let isHandled = false;\n      switch (this.navigation.getState()) {\n        case Constants.STATE.WORKSPACE:\n          isHandled = this.fieldShortcutHandler(workspace, shortcut);\n          if (!isHandled && workspace) {\n            if (\n              !this.navigation.defaultWorkspaceCursorPositionIfNeeded(workspace)\n            ) {\n              workspace.getCursor()?.out();\n            }\n            isHandled = true;\n          }\n          return isHandled;\n        case Constants.STATE.FLYOUT:\n          if (toolbox) {\n            Blockly.getFocusManager().focusTree(toolbox);\n          }\n          return true;\n        case Constants.STATE.TOOLBOX:\n          // @ts-expect-error private method\n          return toolbox && toolbox.selectParent();\n        default:\n          return false;\n      }\n    };\n\n    const shortcuts: {\n      [name: string]: ShortcutRegistry.KeyboardShortcut;\n    } = {\n      /** Go to the next location to the right. */\n      right: {\n        name: Constants.SHORTCUT_NAMES.RIGHT,\n        preconditionFn: (workspace) =>\n          this.navigation.canCurrentlyNavigate(workspace),\n        callback: (workspace, e, shortcut) => {\n          keyboardNavigationController.setIsActive(true);\n          return workspace.RTL\n            ? navigateOut(workspace, e, shortcut)\n            : navigateIn(workspace, e, shortcut);\n        },\n        keyCodes: [KeyCodes.RIGHT],\n      },\n\n      /** Go to the next location to the left. */\n      left: {\n        name: Constants.SHORTCUT_NAMES.LEFT,\n        preconditionFn: (workspace) =>\n          this.navigation.canCurrentlyNavigate(workspace),\n        callback: (workspace, e, shortcut) => {\n          keyboardNavigationController.setIsActive(true);\n          return workspace.RTL\n            ? navigateIn(workspace, e, shortcut)\n            : navigateOut(workspace, e, shortcut);\n        },\n        keyCodes: [KeyCodes.LEFT],\n      },\n\n      /** Go down to the next location. */\n      down: {\n        name: Constants.SHORTCUT_NAMES.DOWN,\n        preconditionFn: (workspace) =>\n          this.navigation.canCurrentlyNavigate(workspace),\n        callback: (workspace, e, shortcut) => {\n          keyboardNavigationController.setIsActive(true);\n          let isHandled = false;\n          switch (this.navigation.getState()) {\n            case Constants.STATE.WORKSPACE:\n              isHandled = this.fieldShortcutHandler(workspace, shortcut);\n              if (!isHandled && workspace) {\n                if (\n                  !this.navigation.defaultWorkspaceCursorPositionIfNeeded(\n                    workspace,\n                  )\n                ) {\n                  workspace.getCursor()?.next();\n                }\n                isHandled = true;\n              }\n              return isHandled;\n            case Constants.STATE.FLYOUT:\n              isHandled = this.fieldShortcutHandler(workspace, shortcut);\n              if (!isHandled && workspace.targetWorkspace) {\n                if (\n                  !this.navigation.defaultFlyoutCursorIfNeeded(\n                    workspace.targetWorkspace,\n                  )\n                ) {\n                  workspace.getCursor()?.next();\n                }\n                isHandled = true;\n              }\n              return isHandled;\n            case Constants.STATE.TOOLBOX: {\n              const toolbox = workspace.getToolbox() as Toolbox;\n              if (toolbox) {\n                if (!toolbox.getSelectedItem()) {\n                  const firstItem =\n                    toolbox\n                      .getToolboxItems()\n                      .find((item) => item.isSelectable()) ?? null;\n                  toolbox.setSelectedItem(firstItem);\n                  isHandled = true;\n                } else {\n                  // @ts-expect-error private method\n                  isHandled = toolbox.selectNext();\n                }\n                const selectedItem = toolbox.getSelectedItem();\n                if (selectedItem) {\n                  Blockly.getFocusManager().focusNode(selectedItem);\n                }\n              }\n              return isHandled;\n            }\n            default:\n              return false;\n          }\n        },\n        keyCodes: [KeyCodes.DOWN],\n      },\n      /** Go up to the previous location. */\n      up: {\n        name: Constants.SHORTCUT_NAMES.UP,\n        preconditionFn: (workspace) =>\n          this.navigation.canCurrentlyNavigate(workspace),\n        callback: (workspace, e, shortcut) => {\n          keyboardNavigationController.setIsActive(true);\n          let isHandled = false;\n          switch (this.navigation.getState()) {\n            case Constants.STATE.WORKSPACE:\n              isHandled = this.fieldShortcutHandler(workspace, shortcut);\n              if (!isHandled) {\n                if (\n                  !this.navigation.defaultWorkspaceCursorPositionIfNeeded(\n                    workspace,\n                    'last',\n                  )\n                ) {\n                  workspace.getCursor()?.prev();\n                }\n                isHandled = true;\n              }\n              return isHandled;\n            case Constants.STATE.FLYOUT:\n              isHandled = this.fieldShortcutHandler(workspace, shortcut);\n              if (!isHandled && workspace.targetWorkspace) {\n                if (\n                  !this.navigation.defaultFlyoutCursorIfNeeded(\n                    workspace.targetWorkspace,\n                    'last',\n                  )\n                ) {\n                  workspace.getCursor()?.prev();\n                }\n                isHandled = true;\n              }\n              return isHandled;\n            case Constants.STATE.TOOLBOX: {\n              const toolbox = workspace.getToolbox() as Toolbox;\n              if (toolbox) {\n                // @ts-expect-error private method\n                isHandled = toolbox.selectPrevious();\n                const selectedItem = toolbox.getSelectedItem();\n                if (selectedItem) {\n                  Blockly.getFocusManager().focusNode(selectedItem);\n                }\n              }\n              return isHandled;\n            }\n            default:\n              return false;\n          }\n        },\n        keyCodes: [KeyCodes.UP],\n      },\n    };\n\n    for (const shortcut of Object.values(shortcuts)) {\n      ShortcutRegistry.registry.register(shortcut);\n    }\n  }\n\n  /**\n   * Removes all the arrow navigation shortcuts.\n   */\n  uninstall() {\n    ShortcutRegistry.registry.unregister(Constants.SHORTCUT_NAMES.LEFT);\n    ShortcutRegistry.registry.unregister(Constants.SHORTCUT_NAMES.RIGHT);\n    ShortcutRegistry.registry.unregister(Constants.SHORTCUT_NAMES.DOWN);\n    ShortcutRegistry.registry.unregister(Constants.SHORTCUT_NAMES.UP);\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  ShortcutRegistry,\n  utils as BlocklyUtils,\n  getFocusManager,\n  Gesture,\n  icons,\n} from 'blockly/core';\n\nimport * as Constants from '../constants';\nimport type {Navigation} from '../navigation';\n\nconst KeyCodes = BlocklyUtils.KeyCodes;\n\n/**\n * Class for registering a shortcut for the exit action.\n */\nexport class ExitAction {\n  constructor(private navigation: Navigation) {}\n\n  /**\n   * Adds the exit action shortcut to the registry.\n   */\n  install() {\n    ShortcutRegistry.registry.register({\n      name: Constants.SHORTCUT_NAMES.EXIT,\n      preconditionFn: (workspace) =>\n        this.navigation.canCurrentlyNavigate(workspace),\n      callback: (workspace) => {\n        switch (this.navigation.getState()) {\n          case Constants.STATE.FLYOUT:\n          case Constants.STATE.TOOLBOX:\n            getFocusManager().focusTree(workspace.targetWorkspace ?? workspace);\n            if (!Gesture.inProgress()) {\n              workspace.hideChaff();\n            }\n            return true;\n          case Constants.STATE.WORKSPACE: {\n            if (workspace.isMutator) {\n              const parent = workspace.options.parentWorkspace\n                ?.getAllBlocks()\n                .map((block) => block.getIcons())\n                .flat()\n                .find(\n                  (icon): icon is icons.MutatorIcon =>\n                    icon instanceof icons.MutatorIcon &&\n                    icon.bubbleIsVisible() &&\n                    icon.getBubble()?.getWorkspace() === workspace,\n                );\n              if (parent) {\n                parent.setBubbleVisible(false);\n                getFocusManager().focusNode(parent);\n                return true;\n              }\n            }\n            return false;\n          }\n          default:\n            return false;\n        }\n      },\n      keyCodes: [KeyCodes.ESC],\n      allowCollision: true,\n    });\n  }\n\n  /**\n   * Removes the exit action shortcut.\n   */\n  uninstall() {\n    ShortcutRegistry.registry.unregister(Constants.SHORTCUT_NAMES.EXIT);\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nexport enum Direction {\n  Up = 1,\n  Down,\n  Left,\n  Right,\n}\n\n/**\n * Convert a direction enum into an XY pair.\n *\n * @param dir The direction, or undefined.\n * @returns An object containing x and y values corresponding to the input\n *     direction.\n */\nexport function getXYFromDirection(dir: Direction | undefined): {\n  x: number;\n  y: number;\n} {\n  if (!dir) {\n    return {x: 0, y: 0};\n  }\n  switch (dir) {\n    case Direction.Up:\n      return {x: 0, y: -1};\n    case Direction.Down:\n      return {x: 0, y: 1};\n    case Direction.Left:\n      return {x: -1, y: 0};\n    case Direction.Right:\n      return {x: 1, y: 0};\n  }\n}\n\n/**\n * Convert an XY pair into a direction enum.\n *\n * @param xy The input pair.\n * @param xy.x The x direction, or undefined.\n * @param xy.y The y direction, or undefined.\n * @returns A direction corresponding to the XY pair, or null if they are invalid\n *     or undefined.\n */\nexport function getDirectionFromXY(xy: {\n  x: number | undefined;\n  y: number | undefined;\n}): Direction | null {\n  const {x, y} = xy;\n  if (x == 0) {\n    if (y == -1) {\n      return Direction.Up;\n    } else if (y == 1) {\n      return Direction.Down;\n    }\n  } else if (y == 0) {\n    if (x == -1) {\n      return Direction.Left;\n    } else if (x == 1) {\n      return Direction.Right;\n    }\n  }\n  return null;\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Bubble that displays a four-way arrow attached to a block to indicate that\n * it is in move mode.\n */\nexport class MoveIndicatorBubble\n  implements Blockly.IBubble, Blockly.IRenderedElement\n{\n  /**\n   * Root SVG element for this bubble.\n   */\n  svgRoot: SVGGElement;\n\n  /**\n   * The location of this bubble in workspace coordinates.\n   */\n  location = new Blockly.utils.Coordinate(0, 0);\n\n  /**\n   * Creates a new move indicator bubble.\n   *\n   * @param sourceBlock The block this bubble should be associated with.\n   */\n  /* eslint-disable @typescript-eslint/naming-convention */\n  constructor(\n    private sourceElement: Blockly.ISelectable & Blockly.IBoundedElement,\n  ) {\n    const workspace = sourceElement.workspace as Blockly.WorkspaceSvg;\n    this.svgRoot = Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.G,\n      {},\n      workspace.getBubbleCanvas(),\n    );\n    const rtl = workspace.RTL;\n    Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.CIRCLE,\n      {\n        'fill': 'white',\n        'fill-opacity': '0.8',\n        'stroke': 'grey',\n        'stroke-width': '1',\n        'r': 20,\n        'cx': 20 * (rtl ? -1 : 1),\n        'cy': 20,\n      },\n      this.svgRoot,\n    );\n    Blockly.utils.dom.createSvgElement(\n      Blockly.utils.Svg.PATH,\n      {\n        'fill': 'none',\n        'stroke': 'black',\n        'stroke-linecap': 'round',\n        'stroke-linejoin': 'round',\n        'stroke-width': '2',\n        'd': 'm18 9l3 3l-3 3m-3-3h6M6 9l-3 3l3 3m-3-3h6m0 6l3 3l3-3m-3-3v6m3-15l-3-3l-3 3m3-3v6',\n        'transform': `translate(${(rtl ? -4 : 1) * 8} 8)`,\n      },\n      this.svgRoot,\n    );\n\n    this.updateLocation();\n  }\n\n  /**\n   * Returns whether this bubble is movable by the user.\n   *\n   * @returns Always returns false.\n   */\n  isMovable(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns the root SVG element for this bubble.\n   *\n   * @returns The root SVG element.\n   */\n  getSvgRoot(): SVGGElement {\n    return this.svgRoot;\n  }\n\n  /**\n   * Recalculates this bubble's location, keeping it adjacent to its block.\n   */\n  updateLocation() {\n    const bounds =\n      this.sourceElement instanceof Blockly.BlockSvg\n        ? this.sourceElement.getBoundingRectangleWithoutChildren()\n        : this.sourceElement.getBoundingRectangle();\n    const x = this.sourceElement.workspace.RTL\n      ? bounds.left + 20\n      : bounds.right - 20;\n    const y = bounds.top - 20;\n    this.moveTo(x, y);\n    (this.sourceElement.workspace as Blockly.WorkspaceSvg)\n      .getLayerManager()\n      ?.moveToDragLayer(this);\n  }\n\n  /**\n   * Moves this bubble to the specified location.\n   *\n   * @param x The location on the X axis to move to.\n   * @param y The location on the Y axis to move to.\n   */\n  moveTo(x: number, y: number) {\n    this.location.x = x;\n    this.location.y = y;\n    this.svgRoot.setAttribute('transform', `translate(${x}, ${y})`);\n  }\n\n  /**\n   * Returns this bubble's location in workspace coordinates.\n   *\n   * @returns The bubble's location.\n   */\n  getRelativeToSurfaceXY(): Blockly.utils.Coordinate {\n    return this.location;\n  }\n\n  /**\n   * Disposes of this move indicator bubble.\n   */\n  dispose() {\n    Blockly.utils.dom.removeNode(this.svgRoot);\n  }\n\n  // These methods are required by the interfaces, but intentionally have no\n  // implementation, largely because this bubble's location is fixed relative\n  // to its block and is not draggable by the user.\n  showContextMenu() {}\n\n  setDragging(dragging: boolean) {}\n\n  startDrag(event: PointerEvent) {}\n\n  drag(newLocation: Blockly.utils.Coordinate, event: PointerEvent) {}\n\n  moveDuringDrag(newLocation: Blockly.utils.Coordinate) {}\n\n  endDrag() {}\n\n  revertDrag() {}\n\n  setDeleteStyle(enable: boolean) {}\n\n  /** See IFocusableNode.getFocusableElement. */\n  getFocusableElement(): HTMLElement | SVGElement {\n    throw new Error('This node is not focusable.');\n  }\n\n  /** See IFocusableNode.getFocusableTree. */\n  getFocusableTree(): Blockly.IFocusableTree {\n    throw new Error('This node is not focusable.');\n  }\n\n  /** See IFocusableNode.onNodeFocus. */\n  onNodeFocus(): void {}\n\n  /** See IFocusableNode.onNodeBlur. */\n  onNodeBlur(): void {}\n\n  /** See IFocusableNode.canBeFocused. */\n  canBeFocused(): boolean {\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {MoveIndicatorBubble} from './move_indicator';\n\n/**\n * Invisible icon that acts as an anchor for a move indicator bubble.\n */\nexport class MoveIcon implements Blockly.IIcon, Blockly.IHasBubble {\n  private moveIndicator: MoveIndicatorBubble;\n  static readonly type = new Blockly.icons.IconType('moveIndicator');\n\n  /**\n   * Creates a new MoveIcon instance.\n   *\n   * @param sourceBlock The block this icon is attached to.\n   */\n  constructor(private sourceBlock: Blockly.BlockSvg) {\n    this.moveIndicator = new MoveIndicatorBubble(this.sourceBlock);\n  }\n\n  /**\n   * Returns the type of this icon.\n   */\n  getType(): Blockly.icons.IconType<MoveIcon> {\n    return MoveIcon.type;\n  }\n\n  /**\n   * Returns the weight of this icon, which controls its position relative to\n   * other icons.\n   *\n   * @returns The weight of this icon.\n   */\n  getWeight(): number {\n    return -1;\n  }\n\n  /**\n   * Returns the size of this icon.\n   *\n   * @returns A rect with negative width and no height to offset the default\n   *     padding applied to icons.\n   */\n  getSize(): Blockly.utils.Size {\n    // Awful hack to cancel out the default padding added to icons.\n    return new Blockly.utils.Size(-8, 0);\n  }\n\n  /**\n   * Returns whether this icon is visible when its parent block is collapsed.\n   *\n   * @returns False since this icon is never visible.\n   */\n  isShownWhenCollapsed(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns whether this icon can be clicked in the flyout.\n   *\n   * @returns False since this icon is invisible and not clickable.\n   */\n  isClickableInFlyout(): boolean {\n    return false;\n  }\n\n  /**\n   * Returns whether this icon's attached bubble is visible.\n   *\n   * @returns True because this icon only exists to host its bubble.\n   */\n  bubbleIsVisible(): boolean {\n    return true;\n  }\n\n  /**\n   * Returns this icon's bubble.\n   */\n  getBubble(): Blockly.IBubble | null {\n    return this.moveIndicator;\n  }\n\n  /**\n   * Called when the location of this icon's block changes.\n   *\n   * @param blockOrigin The new location of this icon's block.\n   */\n  onLocationChange(blockOrigin: Blockly.utils.Coordinate) {\n    this.moveIndicator?.updateLocation();\n  }\n\n  /**\n   * Disposes of this icon.\n   */\n  dispose() {\n    this.moveIndicator?.dispose();\n  }\n\n  // These methods are required by the interfaces, but intentionally have no\n  // implementation, largely because this icon has no visual representation.\n  applyColour() {}\n\n  hideForInsertionMarker() {}\n\n  updateEditable() {}\n\n  updateCollapsed() {}\n\n  setOffsetInBlock() {}\n\n  onClick() {}\n\n  async setBubbleVisible(visible: boolean) {}\n\n  initView(pointerDownListener: (e: PointerEvent) => void) {}\n\n  /** See IFocusableNode.getFocusableElement. */\n  getFocusableElement(): HTMLElement | SVGElement {\n    throw new Error('This node is not focusable.');\n  }\n\n  /** See IFocusableNode.getFocusableTree. */\n  getFocusableTree(): Blockly.IFocusableTree {\n    throw new Error('This node is not focusable.');\n  }\n\n  /** See IFocusableNode.onNodeFocus. */\n  onNodeFocus(): void {}\n\n  /** See IFocusableNode.onNodeBlur. */\n  onNodeBlur(): void {}\n\n  /** See IFocusableNode.canBeFocused. */\n  canBeFocused(): boolean {\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  BlockSvg,\n  ConnectionType,\n  RenderedConnection,\n  dragging,\n  utils,\n} from 'blockly';\nimport {Direction, getDirectionFromXY} from './drag_direction';\nimport {showUnconstrainedMoveHint} from './hints';\nimport {MoveIcon} from './move_icon';\nimport {MoveType} from './actions/mover';\n\n// Copied in from core because it is not exported.\ninterface ConnectionCandidate {\n  /** A connection on the dragging stack that is compatible with neighbour. */\n  local: RenderedConnection;\n\n  /** A nearby connection that is compatible with local. */\n  neighbour: RenderedConnection;\n\n  /** The distance between the local connection and the neighbour connection. */\n  distance: number;\n}\n\n// @ts-expect-error overrides a private function.\nexport class KeyboardDragStrategy extends dragging.BlockDragStrategy {\n  /** Which direction the current constrained drag is in, if any. */\n  private currentDragDirection: Direction | null = null;\n\n  /** Where a constrained movement should start when traversing the tree. */\n  private searchNode: RenderedConnection | null = null;\n\n  constructor(\n    private block: BlockSvg,\n    public moveType: MoveType,\n    private startPoint: RenderedConnection | null,\n  ) {\n    super(block);\n  }\n\n  override startDrag(e?: PointerEvent) {\n    super.startDrag(e);\n    // Set position of the dragging block, so that it doesn't pop\n    // to the top left of the workspace.\n    // @ts-expect-error block and startLoc are private.\n    this.block.moveDuringDrag(this.startLoc);\n    // @ts-expect-error connectionCandidate is private.\n    this.connectionCandidate = this.createInitialCandidate();\n    this.forceShowPreview();\n    this.block.addIcon(new MoveIcon(this.block));\n  }\n\n  override drag(newLoc: utils.Coordinate, e?: PointerEvent): void {\n    if (!e) return;\n    this.currentDragDirection = getDirectionFromXY({x: e.tiltX, y: e.tiltY});\n    super.drag(newLoc);\n\n    // Handle the case when an unconstrained drag found a connection candidate.\n    // @ts-expect-error connectionCandidate is private.\n    if (this.connectionCandidate) {\n      // @ts-expect-error connectionCandidate is private.\n      const neighbour = (this.connectionCandidate as ConnectionCandidate)\n        .neighbour;\n      // The next constrained move will resume the search from the current\n      // candidate location.\n      this.searchNode = neighbour;\n      if (this.isConstrainedMovement()) {\n        // Position the moving block down and slightly to the right of the\n        // target connection.\n        this.block.moveDuringDrag(\n          new utils.Coordinate(neighbour.x + 10, neighbour.y + 10),\n        );\n      }\n    } else {\n      // Handle the case when unconstrained drag was far from any candidate.\n      this.searchNode = null;\n\n      if (this.isConstrainedMovement()) {\n        // @ts-expect-error private field\n        const workspace = this.workspace;\n        showUnconstrainedMoveHint(workspace, true);\n      }\n    }\n  }\n\n  override endDrag(e?: PointerEvent) {\n    super.endDrag(e);\n    this.block.removeIcon(MoveIcon.type);\n  }\n\n  /**\n   * Returns the next compatible connection in keyboard navigation order,\n   * based on the input direction.\n   * Always resumes the search at the last valid connection that was tried.\n   *\n   * @param draggingBlock The block where the drag started.\n   * @returns A valid connection candidate, or null if none was found.\n   */\n  private getConstrainedConnectionCandidate(\n    draggingBlock: BlockSvg,\n  ): ConnectionCandidate | null {\n    // @ts-expect-error getLocalConnections is private.\n    const localConns = this.getLocalConnections(draggingBlock);\n    if (localConns.length == 0) {\n      return null;\n    }\n\n    let candidateConnection = this.findTraversalCandidate(\n      draggingBlock,\n      localConns,\n    );\n    // Fall back on a coordinate-based search if there was no good starting\n    // point for the search.\n    if (!candidateConnection && !this.searchNode) {\n      candidateConnection = this.findNearestCandidate(localConns);\n    }\n    return candidateConnection;\n  }\n\n  /**\n   * Get the nearest valid candidate connection, regardless of direction.\n   * TODO(github.com/google/blockly/issues/8869): Replace with an\n   * override of `getSearchRadius` when implemented in core.\n   *\n   * @param localConns The list of connections on the dragging block(s) that are\n   *     available to connect to.\n   * @returns A candidate connection and radius, or null if none was found.\n   */\n  findNearestCandidate(\n    localConns: RenderedConnection[],\n  ): ConnectionCandidate | null {\n    let radius = Infinity;\n    let candidate = null;\n    const dxy = new utils.Coordinate(0, 0);\n\n    for (const conn of localConns) {\n      const {connection: neighbour, radius: rad} = conn.closest(radius, dxy);\n      if (neighbour) {\n        candidate = {\n          local: conn,\n          neighbour: neighbour,\n          distance: rad,\n        };\n        radius = rad;\n      }\n    }\n    return candidate;\n  }\n\n  /**\n   * Get the nearest valid candidate connection in traversal order.\n   *\n   * @param draggingBlock The root block being dragged.\n   * @param localConns The list of connections on the dragging block(s) that are\n   *     available to connect to.\n   * @returns A candidate connection and radius, or null if none was found.\n   */\n  findTraversalCandidate(\n    draggingBlock: BlockSvg,\n    localConns: RenderedConnection[],\n  ): ConnectionCandidate | null {\n    const connectionChecker = draggingBlock.workspace.connectionChecker;\n    let candidateConnection: ConnectionCandidate | null = null;\n    let potential: RenderedConnection | null = this.searchNode;\n    const allConnections: RenderedConnection[] = [];\n    for (const topBlock of draggingBlock.workspace.getTopBlocks(true)) {\n      allConnections.push(\n        ...topBlock\n          .getDescendants(true)\n          .flatMap((block: BlockSvg) => block.getConnections_(false))\n          .sort((a: RenderedConnection, b: RenderedConnection) => {\n            let delta = a.y - b.y;\n            if (delta === 0) {\n              delta = a.x - b.x;\n            }\n            return delta;\n          }),\n      );\n    }\n\n    const dir = this.currentDragDirection;\n    while (potential && !candidateConnection) {\n      const potentialIndex = allConnections.indexOf(potential);\n      if (dir === Direction.Up || dir === Direction.Left) {\n        potential =\n          allConnections[potentialIndex - 1] ??\n          allConnections[allConnections.length - 1];\n      } else if (dir === Direction.Down || dir === Direction.Right) {\n        potential = allConnections[potentialIndex + 1] ?? allConnections[0];\n      }\n\n      localConns.forEach((conn: RenderedConnection) => {\n        if (\n          potential &&\n          connectionChecker.canConnect(conn, potential, true, Infinity)\n        ) {\n          candidateConnection = {\n            local: conn,\n            neighbour: potential,\n            distance: 0,\n          };\n        }\n      });\n      if (potential == this.searchNode) break;\n    }\n    return candidateConnection;\n  }\n\n  override currCandidateIsBetter(\n    currCandidate: ConnectionCandidate,\n    delta: utils.Coordinate,\n    newCandidate: ConnectionCandidate,\n  ): boolean {\n    if (this.isConstrainedMovement()) {\n      return false; // New connection is always better during a constrained drag.\n    }\n    // @ts-expect-error currCandidateIsBetter is private.\n    return super.currCandidateIsBetter(currCandidate, delta, newCandidate);\n  }\n\n  override getConnectionCandidate(\n    draggingBlock: BlockSvg,\n    delta: utils.Coordinate,\n  ): ConnectionCandidate | null {\n    if (this.isConstrainedMovement()) {\n      return this.getConstrainedConnectionCandidate(draggingBlock);\n    }\n    // @ts-expect-error getConnctionCandidate is private.\n    return super.getConnectionCandidate(draggingBlock, delta);\n  }\n\n  /**\n   * Get whether the most recent drag event represents a constrained\n   * keyboard drag.\n   *\n   * @returns true if the current movement is constrained, otherwise false.\n   */\n  private isConstrainedMovement(): boolean {\n    return !!this.currentDragDirection;\n  }\n\n  /**\n   * Force the preview (replacement or insertion marker) to be shown\n   * immediately. Keyboard drags should always show a preview, even when\n   * the drag has just started; this forces it.\n   */\n  private forceShowPreview() {\n    // @ts-expect-error connectionPreviewer is private\n    const previewer = this.connectionPreviewer;\n    // @ts-expect-error connectionCandidate is private\n    const candidate = this.connectionCandidate as ConnectionCandidate;\n    if (!candidate || !previewer) return;\n    const block = this.block;\n\n    // This is essentially a copy of the second half of updateConnectionPreview\n    // in BlockDragStrategy. It adds a `moveDuringDrag` call at the end.\n    const {local, neighbour} = candidate;\n    const localIsOutputOrPrevious =\n      local.type === ConnectionType.OUTPUT_VALUE ||\n      local.type === ConnectionType.PREVIOUS_STATEMENT;\n\n    const target = neighbour.targetBlock();\n    const neighbourIsConnectedToRealBlock =\n      target && !target.isInsertionMarker();\n\n    const orphanCanConnectAtEnd =\n      target &&\n      // @ts-expect-error orphanCanConnectAtEnd is private\n      this.orphanCanConnectAtEnd(block, target, local.type);\n    if (\n      localIsOutputOrPrevious &&\n      neighbourIsConnectedToRealBlock &&\n      !orphanCanConnectAtEnd\n    ) {\n      previewer.previewReplacement(local, neighbour, target);\n    } else {\n      previewer.previewConnection(local, neighbour);\n    }\n    // The moving block will be positioned slightly down and to the\n    // right of the connection it found.\n    block.moveDuringDrag(\n      new utils.Coordinate(neighbour.x + 10, neighbour.y + 10),\n    );\n  }\n\n  /**\n   * Create a candidate representing where the block was previously connected.\n   * Used to render the block position after picking up the block but before\n   * moving during a drag.\n   *\n   * @returns A connection candidate representing where the block was at the\n   *     start of the drag.\n   */\n  private createInitialCandidate(): ConnectionCandidate | null {\n    // @ts-expect-error startParentConn is private.\n    const neighbour = this.startPoint ?? this.startParentConn;\n    if (neighbour) {\n      this.searchNode = neighbour;\n      switch (neighbour.type) {\n        case ConnectionType.INPUT_VALUE: {\n          if (this.block.outputConnection) {\n            return {\n              neighbour: neighbour,\n              local: this.block.outputConnection,\n              distance: 0,\n            };\n          }\n          break;\n        }\n        case ConnectionType.NEXT_STATEMENT: {\n          if (this.block.previousConnection) {\n            return {\n              neighbour: neighbour,\n              local: this.block.previousConnection,\n              distance: 0,\n            };\n          }\n          break;\n        }\n      }\n    }\n    return null;\n  }\n\n  override shouldHealStack(e: PointerEvent | undefined): boolean {\n    return Boolean(this.block.previousConnection);\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport type {\n  IDragger,\n  IDragStrategy,\n  RenderedConnection,\n  IDraggable,\n  IFocusableNode,\n  IBoundedElement,\n  ISelectable,\n} from 'blockly';\nimport {\n  Connection,\n  dragging,\n  getFocusManager,\n  registry,\n  utils,\n  WorkspaceSvg,\n  ShortcutRegistry,\n  BlockSvg,\n  comments,\n} from 'blockly';\nimport * as Constants from '../constants';\nimport {Direction, getXYFromDirection} from '../drag_direction';\nimport {KeyboardDragStrategy} from '../keyboard_drag_strategy';\nimport {Navigation} from '../navigation';\nimport {clearMoveHints} from '../hints';\nimport {MoveIndicatorBubble} from '../move_indicator';\n\n/**\n * The distance to move an item, in workspace coordinates, when\n * making an unconstrained move.\n */\nconst UNCONSTRAINED_MOVE_DISTANCE = 20;\n\n/**\n * The amount of additional padding to include during a constrained move.\n */\nconst CONSTRAINED_ADDITIONAL_PADDING = 70;\n\n/**\n * Identifier for a keyboard shortcut that commits the in-progress move.\n */\nconst COMMIT_MOVE_SHORTCUT = 'commitMove';\n\n/**\n * Whether this is an insert or a move.\n */\nexport enum MoveType {\n  /**\n   * An insert will remove the block if the move is aborted.\n   */\n  Insert,\n  /**\n   * A regular move of a pre-existing block.\n   */\n  Move,\n}\n\n/**\n * Low-level code for moving elements with keyboard shortcuts.\n */\nexport class Mover {\n  /**\n   * Map of moves in progress.\n   *\n   * An entry for a given workspace in this map means that the this\n   * Mover is moving an element on that workspace, and will disable\n   * normal cursor movement until the move is complete.\n   */\n  protected moves: Map<WorkspaceSvg, MoveInfo> = new Map();\n\n  /**\n   * The element's base drag strategy, which will be overridden during\n   * keyboard drags and reset at the end of the drag.\n   */\n  private oldDragStrategy: IDragStrategy | null = null;\n\n  private moveIndicator?: MoveIndicatorBubble;\n\n  constructor(protected navigation: Navigation) {}\n\n  /**\n   * Returns true iff we are able to begin moving the draggable element which\n   * currently has focus on the given workspace.\n   *\n   * @param workspace The workspace to move on.\n   * @param draggable The draggable element to try to drag.\n   * @returns True iff we can begin a move.\n   */\n  canMove(workspace: WorkspaceSvg, draggable: IDraggable) {\n    return !!(\n      this.navigation.getState() === Constants.STATE.WORKSPACE &&\n      this.navigation.canCurrentlyEdit(workspace) &&\n      !this.moves.has(workspace) && // No move in progress.\n      draggable?.isMovable()\n    );\n  }\n\n  /**\n   * Returns true iff we are currently moving an element on the given\n   * workspace.\n   *\n   * @param workspace The workspace we might be moving on.\n   * @returns True iff we are moving.\n   */\n  isMoving(workspace: WorkspaceSvg) {\n    return (\n      this.navigation.canCurrentlyEdit(workspace) && this.moves.has(workspace)\n    );\n  }\n\n  /**\n   * Start moving the currently-focused item on workspace, if\n   * possible.\n   *\n   * Should only be called if canMove has returned true.\n   *\n   * @param workspace The workspace we might be moving on.\n   * @param draggable The element to start dragging.\n   * @param moveType Whether this is an insert or a move.\n   * @param startPoint Where to start the move, or null to use the current\n   *     location if any.\n   * @returns True iff a move has successfully begun.\n   */\n  startMove(\n    workspace: WorkspaceSvg,\n    draggable: IDraggable & IFocusableNode & IBoundedElement & ISelectable,\n    moveType: MoveType,\n    startPoint: RenderedConnection | null,\n  ) {\n    if (draggable instanceof BlockSvg) {\n      this.patchDragStrategy(draggable, moveType, startPoint);\n    } else if (draggable instanceof comments.RenderedWorkspaceComment) {\n      this.moveIndicator = new MoveIndicatorBubble(draggable);\n    }\n    // Begin dragging element.\n    const DraggerClass = registry.getClassFromOptions(\n      registry.Type.BLOCK_DRAGGER,\n      workspace.options,\n      true,\n    );\n    if (!DraggerClass) throw new Error('no Dragger registered');\n    const dragger = new DraggerClass(draggable, workspace);\n    // Set up a blur listener to end the move if the user clicks away\n    const blurListener = () => {\n      this.finishMove(workspace);\n    };\n    // Record that a move is in progress and start dragging.\n    workspace.setKeyboardMoveInProgress(true);\n    const info = new MoveInfo(workspace, draggable, dragger, blurListener);\n    this.moves.set(workspace, info);\n    // Begin drag.\n    dragger.onDragStart(info.fakePointerEvent('pointerdown'));\n    info.updateTotalDelta();\n    // In case a block is detached, ensure that it still retains focus\n    // (otherwise dragging will break). This is also the point a new block's\n    // initial insert position is scrolled into view.\n    workspace.getCursor()?.setCurNode(draggable);\n    draggable.getFocusableElement().addEventListener('blur', blurListener);\n\n    // Register a keyboard shortcut under the key combos of all existing\n    // keyboard shortcuts that commits the move before allowing the real\n    // shortcut to proceed. This avoids all kinds of fun brokenness when\n    // deleting/copying/otherwise acting on a element in move mode.\n    const shortcutKeys = Object.values(ShortcutRegistry.registry.getRegistry())\n      .flatMap((shortcut) => shortcut.keyCodes)\n      .filter((keyCode) => {\n        return (\n          keyCode &&\n          ![\n            utils.KeyCodes.RIGHT,\n            utils.KeyCodes.LEFT,\n            utils.KeyCodes.UP,\n            utils.KeyCodes.DOWN,\n            utils.KeyCodes.ENTER,\n            utils.KeyCodes.ESC,\n          ].includes(\n            typeof keyCode === 'number'\n              ? keyCode\n              : parseInt(`${keyCode.split('+').pop()}`),\n          )\n        );\n      })\n      // Convince TS there aren't undefined values.\n      .filter((keyCode): keyCode is string | number => !!keyCode);\n\n    const commitMoveShortcut = {\n      name: COMMIT_MOVE_SHORTCUT,\n      preconditionFn: (workspace: WorkspaceSvg) => {\n        return !!this.moves.get(workspace);\n      },\n      callback: (workspace: WorkspaceSvg) => {\n        this.finishMove(workspace);\n        return false;\n      },\n      keyCodes: shortcutKeys,\n      allowCollision: true,\n    };\n\n    ShortcutRegistry.registry.register(commitMoveShortcut);\n\n    return true;\n  }\n\n  /**\n   * Finish moving the currently-focused item on workspace.\n   *\n   * Should only be called if isMoving has returned true.\n   *\n   * @param workspace The workspace on which we are moving.\n   * @returns True iff move successfully finished.\n   */\n  finishMove(workspace: WorkspaceSvg) {\n    const info = this.preDragEndCleanup(workspace);\n\n    info.dragger.onDragEnd(\n      info.fakePointerEvent('pointerup'),\n      new utils.Coordinate(0, 0),\n    );\n\n    this.postDragEndCleanup(workspace, info);\n    return true;\n  }\n\n  /**\n   * Abort moving the currently-focused item on workspace.\n   *\n   * Should only be called if isMoving has returned true.\n   *\n   * @param workspace The workspace on which we are moving.\n   * @returns True iff move successfully aborted.\n   */\n  abortMove(workspace: WorkspaceSvg) {\n    const info = this.preDragEndCleanup(workspace);\n\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    const dragStrategy = (info.draggable as any)\n      .dragStrategy as KeyboardDragStrategy;\n    this.patchDragger(info.dragger as dragging.Dragger, dragStrategy.moveType);\n\n    // Save the position so we can put the cursor in a reasonable spot.\n    // @ts-expect-error Access to private property connectionCandidate.\n    const target = dragStrategy.connectionCandidate?.neighbour;\n\n    // Prevent the strategy connecting the block so we just delete one block.\n    // @ts-expect-error Access to private property connectionCandidate.\n    dragStrategy.connectionCandidate = null;\n\n    info.dragger.onDragEnd(\n      info.fakePointerEvent('pointerup'),\n      info.startLocation,\n    );\n\n    if (dragStrategy.moveType === MoveType.Insert && target) {\n      workspace.getCursor()?.setCurNode(target);\n    }\n\n    this.postDragEndCleanup(workspace, info);\n    return true;\n  }\n\n  /**\n   * Common clean-up for finish/abort.\n   *\n   * @param workspace The workspace on which we are moving.\n   * @returns The info for the element.\n   */\n  private preDragEndCleanup(workspace: WorkspaceSvg) {\n    ShortcutRegistry.registry.unregister(COMMIT_MOVE_SHORTCUT);\n    clearMoveHints(workspace);\n\n    const info = this.moves.get(workspace);\n    if (!info) throw new Error('no move info for workspace');\n\n    // Remove the blur listener before ending the drag\n    info.draggable\n      .getFocusableElement()\n      .removeEventListener('blur', info.blurListener);\n\n    return info;\n  }\n\n  /**\n   * Common clean-up for finish/abort.\n   *\n   * @param workspace The workspace on which we are moving.\n   * @param info The info for the element.\n   */\n  private postDragEndCleanup(workspace: WorkspaceSvg, info: MoveInfo) {\n    this.moveIndicator?.dispose();\n    this.moveIndicator = undefined;\n    if (info.draggable instanceof BlockSvg) {\n      this.unpatchDragStrategy(info.draggable);\n    }\n    this.moves.delete(workspace);\n    workspace.setKeyboardMoveInProgress(false);\n    // Delay scroll until after element has finished moving.\n    setTimeout(() => this.scrollCurrentElementIntoView(workspace), 0);\n    // If a block gets reattached, ensure it retains focus.\n    getFocusManager().focusNode(info.draggable);\n  }\n\n  /**\n   * Action to move the item being moved in the given direction,\n   * constrained to valid attachment points (if any).\n   *\n   * @param workspace The workspace to move on.\n   * @param direction The direction to move the dragged item.\n   * @returns True iff this action applies and has been performed.\n   */\n  moveConstrained(workspace: WorkspaceSvg, direction: Direction) {\n    if (!workspace) return false;\n    const info = this.moves.get(workspace);\n    if (!info) throw new Error('no move info for workspace');\n\n    if (info.draggable instanceof comments.RenderedWorkspaceComment) {\n      return this.moveUnconstrained(workspace, direction);\n    }\n\n    info.dragger.onDrag(\n      info.fakePointerEvent('pointermove', direction),\n      info.totalDelta.clone().scale(workspace.scale),\n    );\n\n    info.updateTotalDelta();\n    this.scrollCurrentElementIntoView(\n      workspace,\n      CONSTRAINED_ADDITIONAL_PADDING,\n    );\n    return true;\n  }\n\n  /**\n   * Action to move the item being moved in the given direction,\n   * without constraint.\n   *\n   * @param workspace The workspace to move on.\n   * @param direction The direction to move the dragged item.\n   * @returns True iff this action applies and has been performed.\n   */\n  moveUnconstrained(workspace: WorkspaceSvg, direction: Direction): boolean {\n    if (!workspace) return false;\n    const info = this.moves.get(workspace);\n    if (!info) throw new Error('no move info for workspace');\n\n    const {x, y} = getXYFromDirection(direction);\n    info.totalDelta.x += x * UNCONSTRAINED_MOVE_DISTANCE * workspace.scale;\n    info.totalDelta.y += y * UNCONSTRAINED_MOVE_DISTANCE * workspace.scale;\n\n    info.dragger.onDrag(\n      info.fakePointerEvent('pointermove'),\n      info.totalDelta.clone().scale(workspace.scale),\n    );\n    this.scrollCurrentElementIntoView(workspace);\n    this.moveIndicator?.updateLocation();\n    return true;\n  }\n\n  /**\n   * Monkeypatch: replace the block's drag strategy and cache the old value.\n   *\n   * @param block The block to patch.\n   * @param moveType Whether this is an insert or a move.\n   * @param startPoint Where to start the move, or null to use the current\n   *     location if any.\n   */\n  private patchDragStrategy(\n    block: BlockSvg,\n    moveType: MoveType,\n    startPoint: RenderedConnection | null,\n  ) {\n    // @ts-expect-error block.dragStrategy is private.\n    this.oldDragStrategy = block.dragStrategy;\n    block.setDragStrategy(\n      new KeyboardDragStrategy(block, moveType, startPoint),\n    );\n  }\n\n  /**\n   * Undo the monkeypatching of the block's drag strategy.\n   *\n   * @param block The block to patch.\n   */\n  private unpatchDragStrategy(block: BlockSvg) {\n    if (this.oldDragStrategy) {\n      block.setDragStrategy(this.oldDragStrategy);\n      this.oldDragStrategy = null;\n    }\n  }\n\n  /**\n   * Scrolls the current element into view.\n   *\n   * @param workspace The workspace to get current element from.\n   * @param padding Amount of spacing to put between the bounds and the edge of\n   *     the workspace's viewport.\n   */\n  private scrollCurrentElementIntoView(workspace: WorkspaceSvg, padding = 0) {\n    const draggable = this.moves.get(workspace)?.draggable;\n    if (draggable) {\n      const bounds = (\n        draggable instanceof BlockSvg\n          ? draggable.getBoundingRectangleWithoutChildren()\n          : draggable.getBoundingRectangle()\n      ).clone();\n      bounds.top -= padding;\n      bounds.bottom += padding;\n      bounds.left -= padding;\n      bounds.right += padding;\n      workspace.scrollBoundsIntoView(bounds);\n    }\n  }\n\n  /**\n   * Monkeypatch: override either wouldDeleteDraggable or shouldReturnToStart,\n   * based on whether this was an insertion of a new block or a movement of\n   * an existing element.\n   *\n   * @param dragger The dragger to patch.\n   * @param moveType Whether this is an insert or a move.\n   */\n  private patchDragger(dragger: dragging.Dragger, moveType: MoveType) {\n    if (moveType === MoveType.Insert) {\n      // Monkey patch dragger to trigger delete.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (dragger as any).wouldDeleteDraggable = () => true;\n    } else {\n      // Monkey patch dragger to trigger call to draggable.revertDrag.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      (dragger as any).shouldReturnToStart = () => true;\n    }\n  }\n}\n\n/**\n * Information about the currently in-progress move for a given\n * Workspace.\n */\nexport class MoveInfo {\n  /** Total distance moved, in workspace units. */\n  totalDelta = new utils.Coordinate(0, 0);\n  readonly parentNext: Connection | null = null;\n  readonly parentInput: Connection | null = null;\n  readonly startLocation: utils.Coordinate;\n\n  constructor(\n    readonly workspace: WorkspaceSvg,\n    readonly draggable: IDraggable & IFocusableNode & IBoundedElement,\n    readonly dragger: IDragger,\n    readonly blurListener: EventListener,\n  ) {\n    if (draggable instanceof BlockSvg) {\n      this.parentNext = draggable.previousConnection?.targetConnection ?? null;\n      this.parentInput = draggable.outputConnection?.targetConnection ?? null;\n    }\n    this.startLocation = draggable.getRelativeToSurfaceXY();\n  }\n\n  /**\n   * Create a fake pointer event for dragging.\n   *\n   * @param type Which type of pointer event to create.\n   * @param direction The direction if this movement is a constrained drag.\n   * @returns A synthetic PointerEvent that can be consumed by Blockly's\n   *     dragging code.\n   */\n  fakePointerEvent(type: string, direction?: Direction): PointerEvent {\n    const coordinates = utils.svgMath.wsToScreenCoordinates(\n      this.workspace,\n      new utils.Coordinate(\n        this.startLocation.x + this.totalDelta.x,\n        this.startLocation.y + this.totalDelta.y,\n      ),\n    );\n    const tilts = getXYFromDirection(direction);\n    return new PointerEvent(type, {\n      clientX: coordinates.x,\n      clientY: coordinates.y,\n      tiltX: tilts.x,\n      tiltY: tilts.y,\n    });\n  }\n\n  /**\n   * The keyboard drag may have moved a block to an appropriate location\n   * for a preview. Update the saved delta to reflect the element's new\n   * location, so that it does not jump during the next unconstrained move.\n   */\n  updateTotalDelta() {\n    if (this.draggable instanceof BlockSvg) {\n      this.totalDelta = new utils.Coordinate(\n        this.draggable.relativeCoords.x - this.startLocation.x,\n        this.draggable.relativeCoords.y - this.startLocation.y,\n      );\n    } else {\n      this.totalDelta = new utils.Coordinate(\n        this.draggable.getBoundingRectangle().left - this.startLocation.x,\n        this.draggable.getBoundingRectangle().top - this.startLocation.y,\n      );\n    }\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  Events,\n  ShortcutRegistry,\n  utils as BlocklyUtils,\n  BlockSvg,\n  FlyoutButton,\n  RenderedConnection,\n  WorkspaceSvg,\n  Field,\n  icons,\n  FocusableTreeTraverser,\n  renderManagement,\n  comments,\n  getFocusManager,\n} from 'blockly/core';\n\nimport type {Block} from 'blockly/core';\n\nimport * as Constants from '../constants';\nimport type {Navigation} from '../navigation';\nimport {Mover, MoveType} from './mover';\nimport {\n  showConstrainedMovementHint,\n  showHelpHint,\n  showUnconstrainedMoveHint,\n} from '../hints';\n\nconst KeyCodes = BlocklyUtils.KeyCodes;\n\n/**\n * Class for registering a shortcut for the enter action.\n */\nexport class EnterAction {\n  constructor(\n    private mover: Mover,\n    private navigation: Navigation,\n  ) {}\n\n  /**\n   * Adds the enter action shortcut to the registry.\n   */\n  install() {\n    /**\n     * Enter key:\n     *\n     * - On the flyout: press a button or choose a block to place.\n     * - On a stack: open a block's context menu or field's editor.\n     * - On the workspace: open the context menu.\n     */\n    ShortcutRegistry.registry.register({\n      name: Constants.SHORTCUT_NAMES.EDIT_OR_CONFIRM,\n      preconditionFn: (workspace): boolean => {\n        switch (this.navigation.getState()) {\n          case Constants.STATE.WORKSPACE:\n            return this.shouldHandleEnterForWS(workspace);\n          case Constants.STATE.FLYOUT: {\n            // If we're in the flyout the only supported actions are inserting\n            // blocks or clicking buttons, so don't handle this if the\n            // main workspace is read only.\n            const targetWorkspace = workspace.isFlyout\n              ? workspace.targetWorkspace\n              : workspace;\n            if (!targetWorkspace) return false;\n            return this.navigation.canCurrentlyEdit(targetWorkspace);\n          }\n          default:\n            return false;\n        }\n      },\n      callback: (workspace, event): boolean => {\n        event.preventDefault();\n\n        const targetWorkspace = workspace.isFlyout\n          ? workspace.targetWorkspace\n          : workspace;\n        if (!targetWorkspace) return false;\n\n        let flyoutCursor;\n        let curNode;\n\n        switch (this.navigation.getState()) {\n          case Constants.STATE.WORKSPACE:\n            return this.handleEnterForWS(workspace);\n          case Constants.STATE.FLYOUT:\n            flyoutCursor = this.navigation.getFlyoutCursor(targetWorkspace);\n            if (!flyoutCursor) {\n              return false;\n            }\n            curNode = flyoutCursor.getCurNode();\n            if (curNode instanceof BlockSvg) {\n              this.insertFromFlyout(targetWorkspace);\n            } else if (curNode instanceof FlyoutButton) {\n              this.triggerButtonCallback(targetWorkspace);\n            }\n            return true;\n          default:\n            return false;\n        }\n      },\n      keyCodes: [KeyCodes.ENTER, KeyCodes.SPACE],\n    });\n  }\n\n  /**\n   * Checks if the enter key should do anything for this ws.\n   *\n   * @param workspace The workspace to check.\n   * @returns True if the enter action should be handled.\n   */\n  private shouldHandleEnterForWS(workspace: WorkspaceSvg): boolean {\n    if (!this.navigation.canCurrentlyNavigate(workspace)) return false;\n\n    const cursor = workspace.getCursor();\n    const curNode = cursor?.getCurNode();\n    if (!curNode) return false;\n    if (curNode instanceof Field) return curNode.isClickable();\n    if (\n      curNode instanceof RenderedConnection ||\n      curNode instanceof WorkspaceSvg\n    ) {\n      return !workspace.isReadOnly();\n    }\n    // Returning true is sometimes incorrect for icons, but there's no API to check.\n    return (\n      curNode instanceof BlockSvg ||\n      curNode instanceof icons.Icon ||\n      curNode instanceof comments.CommentBarButton ||\n      curNode instanceof comments.RenderedWorkspaceComment\n    );\n  }\n\n  /**\n   * Handles hitting the enter key on the workspace.\n   *\n   * @param workspace The workspace.\n   * @returns True if the enter was handled, false otherwise.\n   */\n  private handleEnterForWS(workspace: WorkspaceSvg): boolean {\n    const cursor = workspace.getCursor();\n    const curNode = cursor?.getCurNode();\n    if (!curNode) return false;\n    if (curNode instanceof Field) {\n      curNode.showEditor();\n      return true;\n    } else if (curNode instanceof BlockSvg) {\n      if (!this.tryShowFullBlockFieldEditor(curNode)) {\n        showHelpHint(workspace);\n      }\n      return true;\n    } else if (\n      curNode instanceof RenderedConnection ||\n      curNode instanceof WorkspaceSvg\n    ) {\n      this.navigation.openToolboxOrFlyout(workspace);\n      return true;\n    } else if (curNode instanceof icons.Icon) {\n      // Calling the icon's click handler will trigger its action, generally\n      // opening a bubble of some sort. We then need to wait for the bubble to\n      // appear before attempting to navigate into it.\n      curNode.onClick();\n      // This currently only works for MutatorIcons.\n      // See icon_navigation_policy.\n      if (curNode instanceof icons.MutatorIcon) {\n        renderManagement.finishQueuedRenders().then(() => {\n          cursor?.in();\n        });\n      }\n      return true;\n    } else if (curNode instanceof comments.CommentBarButton) {\n      curNode.performAction();\n      return true;\n    } else if (curNode instanceof comments.RenderedWorkspaceComment) {\n      curNode.setCollapsed(false);\n      getFocusManager().focusNode(curNode.getEditorFocusableNode());\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Inserts a block from the flyout.\n   * Tries to find a connection on the block to connect to the marked\n   * location. If no connection has been marked, or there is not a compatible\n   * connection then the block is placed on the workspace.\n   * Trigger a toast per session if possible.\n   *\n   * @param workspace The main workspace. The workspace\n   *     the block will be placed on.\n   */\n  private insertFromFlyout(workspace: WorkspaceSvg) {\n    workspace.setResizesEnabled(false);\n    // Create a new event group or append to the existing group.\n    const existingGroup = Events.getGroup();\n    if (!existingGroup) {\n      Events.setGroup(true);\n    }\n\n    // If the workspace has never had focus default the stationary node.\n    const stationaryNode =\n      FocusableTreeTraverser.findFocusedNode(workspace) ??\n      workspace.getRestoredFocusableNode(null);\n    const newBlock = this.createNewBlock(workspace);\n    if (!newBlock) return;\n    const insertStartPoint = stationaryNode\n      ? this.navigation.findInsertStartPoint(stationaryNode, newBlock)\n      : null;\n\n    if (workspace.getTopBlocks().includes(newBlock)) {\n      this.positionNewTopLevelBlock(workspace, newBlock);\n    }\n\n    workspace.setResizesEnabled(true);\n\n    this.mover.startMove(\n      workspace,\n      newBlock,\n      MoveType.Insert,\n      insertStartPoint,\n    );\n\n    const isStartBlock =\n      !newBlock.outputConnection &&\n      !newBlock.nextConnection &&\n      !newBlock.previousConnection;\n    if (isStartBlock) {\n      showUnconstrainedMoveHint(workspace, false);\n    } else {\n      showConstrainedMovementHint(workspace);\n    }\n  }\n\n  /**\n   * Position a new top-level block to avoid overlap at the top left.\n   *\n   * Similar to `WorkspaceSvg.cleanUp()` but does not constrain itself to not\n   * affecting code ordering in order to use horizontal space.\n   *\n   * @param workspace The workspace.\n   * @param newBlock The top-level block to move to free space.\n   */\n  private positionNewTopLevelBlock(\n    workspace: WorkspaceSvg,\n    newBlock: BlockSvg,\n  ) {\n    const initialY = 10;\n    const initialX = 10;\n    const xSpacing = 80;\n\n    const filteredTopBlocks = workspace\n      .getTopBlocks(true)\n      .filter((block) => block.id !== newBlock.id);\n    const allBlockBounds = filteredTopBlocks.map((block) =>\n      block.getBoundingRectangle(),\n    );\n\n    const toolboxWidth = workspace.getToolbox()?.getWidth();\n    const workspaceWidth =\n      workspace.getParentSvg().clientWidth - (toolboxWidth ?? 0);\n    const workspaceHeight = workspace.getParentSvg().clientHeight;\n    const {height: newBlockHeight, width: newBlockWidth} =\n      newBlock.getHeightWidth();\n\n    const getNextIntersectingBlock = function (\n      newBlockRect: BlocklyUtils.Rect,\n    ): BlocklyUtils.Rect | null {\n      for (const rect of allBlockBounds) {\n        if (newBlockRect.intersects(rect)) {\n          return rect;\n        }\n      }\n      return null;\n    };\n\n    let cursorY = initialY;\n    let cursorX = initialX;\n    const minBlockHeight = workspace\n      .getRenderer()\n      .getConstants().MIN_BLOCK_HEIGHT;\n    // Make the initial movement of shifting the block to its best possible position.\n    let boundingRect = newBlock.getBoundingRectangle();\n    newBlock.moveBy(cursorX - boundingRect.left, cursorY - boundingRect.top, [\n      'cleanup',\n    ]);\n    newBlock.snapToGrid();\n\n    boundingRect = newBlock.getBoundingRectangle();\n    let conflictingRect = getNextIntersectingBlock(boundingRect);\n    while (conflictingRect != null) {\n      const newCursorX =\n        conflictingRect.left + conflictingRect.getWidth() + xSpacing;\n      const newCursorY =\n        conflictingRect.top + conflictingRect.getHeight() + minBlockHeight;\n      if (newCursorX + newBlockWidth <= workspaceWidth) {\n        cursorX = newCursorX;\n      } else if (newCursorY + newBlockHeight <= workspaceHeight) {\n        cursorY = newCursorY;\n        cursorX = initialX;\n      } else {\n        // Off screen, but new blocks will be selected which will scroll them\n        // into view.\n        cursorY = newCursorY;\n        cursorX = initialX;\n      }\n      newBlock.moveBy(cursorX - boundingRect.left, cursorY - boundingRect.top, [\n        'cleanup',\n      ]);\n      newBlock.snapToGrid();\n      boundingRect = newBlock.getBoundingRectangle();\n      conflictingRect = getNextIntersectingBlock(boundingRect);\n    }\n\n    newBlock.bringToFront();\n  }\n\n  /**\n   * Triggers a flyout button's callback.\n   *\n   * @param workspace The main workspace. The workspace\n   *     containing a flyout with a button.\n   */\n  private triggerButtonCallback(workspace: WorkspaceSvg) {\n    const button = this.navigation.getFlyoutCursor(workspace)?.getCurNode();\n    if (!(button instanceof FlyoutButton)) return;\n\n    const flyoutButtonCallbacks: Map<string, (p1: FlyoutButton) => void> =\n      // @ts-expect-error private field access\n      workspace.flyoutButtonCallbacks;\n\n    const info = button.info;\n    if ('callbackkey' in info) {\n      const buttonCallback = flyoutButtonCallbacks.get(info.callbackkey);\n      if (!buttonCallback) {\n        throw new Error('No callback function found for flyout button.');\n      }\n      buttonCallback(button);\n    }\n  }\n\n  /**\n   * If this block has a full block field then show its editor.\n   *\n   * @param block A block.\n   * @returns True if we showed the editor, false otherwise.\n   */\n  private tryShowFullBlockFieldEditor(block: Block): boolean {\n    if (block.isSimpleReporter()) {\n      for (const input of block.inputList) {\n        for (const field of input.fieldRow) {\n          if (field.isClickable() && field.isFullBlockField()) {\n            field.showEditor();\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Creates a new block based on the current block the flyout cursor is on.\n   *\n   * @param workspace The main workspace. The workspace\n   *     the block will be placed on.\n   * @returns The newly created block.\n   */\n  private createNewBlock(workspace: WorkspaceSvg): BlockSvg | null {\n    const flyout = workspace.getFlyout();\n    if (!flyout || !flyout.isVisible()) {\n      console.warn(\n        'Trying to insert from the flyout when the flyout does not ' +\n          ' exist or is not visible',\n      );\n      return null;\n    }\n\n    const curBlock = this.navigation.getFlyoutCursor(workspace)?.getCurNode();\n    if (!(curBlock instanceof BlockSvg) || !curBlock.isEnabled()) {\n      console.warn(\"Can't insert a disabled block.\");\n      return null;\n    }\n\n    const newBlock = flyout.createBlock(curBlock);\n    // Render to get the sizing right.\n    newBlock.render();\n    // Connections are not tracked when the block is first created.  Normally\n    // there's enough time for them to become tracked in the user's mouse\n    // movements, but not here.\n    newBlock.setConnectionTracking(true);\n    return newBlock;\n  }\n\n  /**\n   * Removes the enter action shortcut.\n   */\n  uninstall() {\n    ShortcutRegistry.registry.unregister(\n      Constants.SHORTCUT_NAMES.EDIT_OR_CONFIRM,\n    );\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  BlockSvg,\n  Events,\n  ShortcutRegistry,\n  utils as BlocklyUtils,\n  keyboardNavigationController,\n} from 'blockly';\nimport * as Constants from '../constants';\nimport type {WorkspaceSvg} from 'blockly';\nimport {Navigation} from '../navigation';\n\nconst KeyCodes = BlocklyUtils.KeyCodes;\n\n/**\n * Action to insert a block into the workspace.\n *\n * This action registers itself as both a keyboard shortcut and a context menu\n * item.\n */\nexport class DisconnectAction {\n  /**\n   * Registration name for the keyboard shortcut.\n   */\n  private shortcutName = Constants.SHORTCUT_NAMES.DISCONNECT;\n\n  constructor(private navigation: Navigation) {}\n\n  /**\n   * Install this action as both a keyboard shortcut and a context menu item.\n   */\n  install() {\n    this.registerShortcut();\n  }\n\n  /**\n   * Uninstall this action as both a keyboard shortcut and a context menu item.\n   * Reinstall the original context menu action if possible.\n   */\n  uninstall() {\n    ShortcutRegistry.registry.unregister(this.shortcutName);\n  }\n\n  /**\n   * Create and register the keyboard shortcut for this action.\n   */\n  private registerShortcut() {\n    const disconnectShortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: this.shortcutName,\n      preconditionFn: (workspace) =>\n        this.navigation.canCurrentlyEdit(workspace),\n      callback: (workspace) => {\n        keyboardNavigationController.setIsActive(true);\n        switch (this.navigation.getState()) {\n          case Constants.STATE.WORKSPACE:\n            this.disconnectBlocks(workspace);\n            return true;\n          default:\n            return false;\n        }\n      },\n      keyCodes: [KeyCodes.X],\n    };\n    ShortcutRegistry.registry.register(disconnectShortcut);\n  }\n\n  /**\n   * Disconnects the connection that the cursor is pointing to, and bump blocks.\n   * This is a no-op if the connection cannot be broken or if the cursor is not\n   * pointing to a connection.\n   *\n   * @param workspace The workspace.\n   */\n  disconnectBlocks(workspace: WorkspaceSvg) {\n    const cursor = workspace.getCursor();\n    if (!cursor) return;\n    const curNode = cursor.getCurNode();\n    if (!(curNode instanceof BlockSvg)) return;\n\n    const healStack = !curNode.outputConnection?.isConnected();\n    Events.setGroup(true);\n    curNode.unplug(healStack);\n    Events.setGroup(false);\n\n    // Needed or we end up with passive focus.\n    cursor.setCurNode(curNode);\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ShortcutRegistry, utils as BlocklyUtils, WidgetDiv} from 'blockly';\nimport * as Constants from '../constants';\nimport type {WorkspaceSvg} from 'blockly';\nimport {Navigation} from '../navigation';\n\nconst KeyCodes = BlocklyUtils.KeyCodes;\nconst createSerializedKey = ShortcutRegistry.registry.createSerializedKey.bind(\n  ShortcutRegistry.registry,\n);\n\n/**\n * Keyboard shortcut to show the action menu on Cmd/Ctrl/Alt+Enter key.\n */\nexport class ActionMenu {\n  /**\n   * Registration name for the keyboard shortcut.\n   */\n  private shortcutName = Constants.SHORTCUT_NAMES.MENU;\n\n  constructor(private navigation: Navigation) {}\n\n  /**\n   * Install this action.\n   */\n  install() {\n    this.registerShortcut();\n  }\n\n  /**\n   * Uninstall this action.\n   */\n  uninstall() {\n    ShortcutRegistry.registry.unregister(this.shortcutName);\n  }\n\n  /**\n   * Create and register the keyboard shortcut for this action.\n   */\n  private registerShortcut() {\n    const menuShortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.MENU,\n      preconditionFn: (workspace) => {\n        return (\n          this.navigation.canCurrentlyNavigate(workspace) &&\n          !workspace.isDragging()\n        );\n      },\n      callback: (workspace) => {\n        switch (this.navigation.getState()) {\n          case Constants.STATE.WORKSPACE:\n          case Constants.STATE.FLYOUT:\n            return this.openActionMenu(workspace);\n          default:\n            return false;\n        }\n      },\n      keyCodes: [\n        createSerializedKey(KeyCodes.ENTER, [KeyCodes.CTRL]),\n        createSerializedKey(KeyCodes.ENTER, [KeyCodes.ALT]),\n        createSerializedKey(KeyCodes.ENTER, [KeyCodes.META]),\n      ],\n    };\n    ShortcutRegistry.registry.register(menuShortcut);\n  }\n\n  /**\n   * Show the action menu for the current node.\n   *\n   * The action menu will contain entries for relevant actions for the\n   * node's location.  If the location is a block, this will include\n   * the contents of the block's context menu (if any).\n   *\n   * Returns true if it is possible to open the action menu in the\n   * current location, even if the menu was not opened due there being\n   * no applicable menu items.\n   *\n   * @param workspace The workspace.\n   */\n  private openActionMenu(workspace: WorkspaceSvg): boolean {\n    // TODO(#362): Pass this through the precondition and callback instead of making it up.\n    const menuOpenEvent = new KeyboardEvent('keydown');\n\n    const cursor = workspace.getCursor();\n    if (!cursor) throw new Error('workspace has no cursor');\n    const node = cursor.getCurNode();\n    if (!node) return false;\n    // TODO(google/blockly#8847): Add typeguard for IContextMenu in core when this moves over\n    if (\n      'showContextMenu' in node &&\n      typeof node.showContextMenu === 'function'\n    ) {\n      node.showContextMenu(menuOpenEvent);\n    } else {\n      console.info(`No action menu for node ${node}`);\n      return false;\n    }\n\n    setTimeout(() => {\n      WidgetDiv.getDiv()\n        ?.querySelector('.blocklyMenu')\n        ?.dispatchEvent(\n          new KeyboardEvent('keydown', {\n            key: 'ArrowDown',\n            code: 'ArrowDown',\n            keyCode: KeyCodes.DOWN,\n            which: KeyCodes.DOWN,\n            bubbles: true,\n            cancelable: true,\n          }),\n        );\n    }, 10);\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  ContextMenuRegistry,\n  Msg,\n  ShortcutRegistry,\n  utils,\n  WorkspaceSvg,\n  keyboardNavigationController,\n  getFocusManager,\n  comments,\n  IDraggable,\n  IFocusableNode,\n  IBoundedElement,\n  ISelectable,\n} from 'blockly';\nimport {Direction} from '../drag_direction';\nimport {Mover, MoveType} from './mover';\nimport {getMenuItem} from '../shortcut_formatting';\n\nconst KeyCodes = utils.KeyCodes;\nconst createSerializedKey = ShortcutRegistry.registry.createSerializedKey.bind(\n  ShortcutRegistry.registry,\n);\n\n/**\n * Actions for moving workspace elements with keyboard shortcuts.\n */\nexport class MoveActions {\n  constructor(private mover: Mover) {}\n\n  private shortcutNames: string[] = [];\n  private menuItemNames: string[] = [];\n\n  private registerShortcuts() {\n    const shortcuts: ShortcutRegistry.KeyboardShortcut[] = [\n      // Begin and end move.\n      {\n        name: 'start_move',\n        preconditionFn: (workspace) => {\n          const startDraggable = this.getCurrentDraggable(workspace);\n          return (\n            !!startDraggable && this.mover.canMove(workspace, startDraggable)\n          );\n        },\n        callback: (workspace) => {\n          keyboardNavigationController.setIsActive(true);\n          const startDraggable = this.getCurrentDraggable(workspace);\n          // Focus the root draggable in case one of its children\n          // was focused when the move was triggered.\n          if (startDraggable) {\n            getFocusManager().focusNode(startDraggable);\n          }\n          return (\n            !!startDraggable &&\n            this.mover.startMove(workspace, startDraggable, MoveType.Move, null)\n          );\n        },\n        keyCodes: [KeyCodes.M],\n      },\n      {\n        name: 'finish_move',\n        preconditionFn: (workspace) => this.mover.isMoving(workspace),\n        callback: (workspace) => this.mover.finishMove(workspace),\n        keyCodes: [KeyCodes.ENTER, KeyCodes.SPACE],\n        allowCollision: true,\n      },\n      {\n        name: 'abort_move',\n        preconditionFn: (workspace) => this.mover.isMoving(workspace),\n        callback: (workspace) => this.mover.abortMove(workspace),\n        keyCodes: [KeyCodes.ESC],\n        allowCollision: true,\n      },\n\n      // Constrained moves.\n      {\n        name: 'move_left_constrained',\n        preconditionFn: (workspace) => this.mover.isMoving(workspace),\n        callback: (workspace) =>\n          this.mover.moveConstrained(workspace, Direction.Left),\n        keyCodes: [KeyCodes.LEFT],\n        allowCollision: true,\n      },\n      {\n        name: 'move_right_constrained',\n        preconditionFn: (workspace) => this.mover.isMoving(workspace),\n        callback: (workspace) =>\n          this.mover.moveConstrained(workspace, Direction.Right),\n        keyCodes: [KeyCodes.RIGHT],\n        allowCollision: true,\n      },\n      {\n        name: 'move_up_constrained',\n        preconditionFn: (workspace) => this.mover.isMoving(workspace),\n        callback: (workspace) =>\n          this.mover.moveConstrained(workspace, Direction.Up),\n        keyCodes: [KeyCodes.UP],\n        allowCollision: true,\n      },\n      {\n        name: 'move_down_constrained',\n        preconditionFn: (workspace) => this.mover.isMoving(workspace),\n        callback: (workspace) =>\n          this.mover.moveConstrained(workspace, Direction.Down),\n        keyCodes: [KeyCodes.DOWN],\n        allowCollision: true,\n      },\n\n      // Unconstrained moves.\n      {\n        name: 'move_left_unconstrained',\n        preconditionFn: (workspace) => this.mover.isMoving(workspace),\n        callback: (workspace) =>\n          this.mover.moveUnconstrained(workspace, Direction.Left),\n        keyCodes: [\n          createSerializedKey(KeyCodes.LEFT, [KeyCodes.ALT]),\n          createSerializedKey(KeyCodes.LEFT, [KeyCodes.CTRL]),\n        ],\n      },\n      {\n        name: 'move_right_unconstrained',\n        preconditionFn: (workspace) => this.mover.isMoving(workspace),\n        callback: (workspace) =>\n          this.mover.moveUnconstrained(workspace, Direction.Right),\n        keyCodes: [\n          createSerializedKey(KeyCodes.RIGHT, [KeyCodes.ALT]),\n          createSerializedKey(KeyCodes.RIGHT, [KeyCodes.CTRL]),\n        ],\n      },\n      {\n        name: 'move_up_unconstrained',\n        preconditionFn: (workspace) => this.mover.isMoving(workspace),\n        callback: (workspace) =>\n          this.mover.moveUnconstrained(workspace, Direction.Up),\n        keyCodes: [\n          createSerializedKey(KeyCodes.UP, [KeyCodes.ALT]),\n          createSerializedKey(KeyCodes.UP, [KeyCodes.CTRL]),\n        ],\n      },\n      {\n        name: 'move_down_unconstrained',\n        preconditionFn: (workspace) => this.mover.isMoving(workspace),\n        callback: (workspace) =>\n          this.mover.moveUnconstrained(workspace, Direction.Down),\n        keyCodes: [\n          createSerializedKey(KeyCodes.DOWN, [KeyCodes.ALT]),\n          createSerializedKey(KeyCodes.DOWN, [KeyCodes.CTRL]),\n        ],\n      },\n    ];\n\n    for (const shortcut of shortcuts) {\n      ShortcutRegistry.registry.register(shortcut);\n      this.shortcutNames.push(shortcut.name);\n    }\n  }\n\n  private registerMenuItems() {\n    const menuItems: ContextMenuRegistry.RegistryItem[] = [\n      {\n        displayText: getMenuItem(Msg['MOVE_BLOCK'], 'start_move'),\n        preconditionFn: (scope, menuOpenEvent) => {\n          const workspace = scope.block?.workspace as WorkspaceSvg | null;\n          if (!workspace || menuOpenEvent instanceof PointerEvent)\n            return 'hidden';\n\n          const startDraggable = this.getCurrentDraggable(workspace);\n          return !!startDraggable &&\n            this.mover.canMove(workspace, startDraggable)\n            ? 'enabled'\n            : 'disabled';\n        },\n        callback: (scope) => {\n          const workspace = scope.block?.workspace as WorkspaceSvg | null;\n          if (!workspace) return false;\n          const startDraggable = this.getCurrentDraggable(workspace);\n          // Focus the start block in case one of its fields or a shadow block\n          // was focused when the move was triggered.\n          if (startDraggable) {\n            getFocusManager().focusNode(startDraggable);\n          }\n          return (\n            !!startDraggable &&\n            this.mover.startMove(workspace, startDraggable, MoveType.Move, null)\n          );\n        },\n        scopeType: ContextMenuRegistry.ScopeType.BLOCK,\n        id: 'move',\n        weight: 8.5,\n      },\n      {\n        displayText: getMenuItem(\n          Msg['MOVE_COMMENT'] ?? 'Move Comment',\n          'start_move',\n        ),\n        preconditionFn: (scope, menuOpenEvent) => {\n          const comment = scope.comment;\n          if (!comment) return 'hidden';\n\n          return this.mover.canMove(comment.workspace, comment)\n            ? 'enabled'\n            : 'disabled';\n        },\n        callback: (scope) => {\n          const comment = scope.comment;\n          if (!comment) return false;\n          this.mover.startMove(comment.workspace, comment, MoveType.Move, null);\n        },\n        scopeType: ContextMenuRegistry.ScopeType.COMMENT,\n        id: 'move_comment',\n        weight: 8.5,\n      },\n    ];\n\n    for (const menuItem of menuItems) {\n      ContextMenuRegistry.registry.register(menuItem);\n      this.menuItemNames.push(menuItem.id);\n    }\n  }\n\n  /**\n   * Install the actions as both keyboard shortcuts and (where\n   * applicable) context menu items.\n   */\n  install() {\n    this.registerShortcuts();\n    this.registerMenuItems();\n  }\n\n  /**\n   * Uninstall these actions.\n   */\n  uninstall() {\n    for (const shortcut of this.shortcutNames) {\n      ShortcutRegistry.registry.unregister(shortcut);\n    }\n    for (const menuItem of this.menuItemNames) {\n      ContextMenuRegistry.registry.unregister(menuItem);\n    }\n  }\n\n  /**\n   * Get the source draggable for the cursor location, or undefined if no\n   * source draggable can be found.\n   * If the cursor is on a shadow block, walks up the tree until it finds\n   * a non-shadow block to drag.\n   *\n   * @param workspace The workspace to inspect for a cursor.\n   * @returns The source draggable, or undefined if no appropriate draggable\n   *     could be found.\n   */\n  getCurrentDraggable(\n    workspace: WorkspaceSvg,\n  ): (IDraggable & IFocusableNode & IBoundedElement & ISelectable) | undefined {\n    const node = getFocusManager().getFocusedNode();\n    if (node instanceof comments.RenderedWorkspaceComment) return node;\n\n    let block = workspace?.getCursor()?.getSourceBlock();\n    if (!block) return undefined;\n    while (block.isShadow()) {\n      block = block.getParent();\n      if (!block) {\n        throw new Error(\n          'Tried to drag a shadow block with no parent. ' +\n            'Shadow blocks should always have parents.',\n        );\n      }\n    }\n    return block;\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {\n  BlockSvg,\n  clipboard,\n  ContextMenuRegistry,\n  ICopyable,\n  ShortcutRegistry,\n  utils,\n  comments,\n  ICopyData,\n} from 'blockly';\nimport * as Constants from '../constants';\nimport {getMenuItem} from '../shortcut_formatting';\n\n/**\n * Duplicate action that adds a keyboard shortcut for duplicate and overrides\n * the context menu item to show it if the context menu item is registered.\n */\nexport class DuplicateAction {\n  private duplicateShortcut: ShortcutRegistry.KeyboardShortcut | null = null;\n  private uninstallHandlers: Array<() => void> = [];\n\n  /**\n   * Install the shortcuts and override context menu entries.\n   *\n   * No change is made if there's already a 'duplicate' shortcut.\n   */\n  install() {\n    this.duplicateShortcut = this.registerDuplicateShortcut();\n    if (this.duplicateShortcut) {\n      this.uninstallHandlers.push(\n        overrideContextMenuItemForShortcutText(\n          'blockDuplicate',\n          Constants.SHORTCUT_NAMES.DUPLICATE,\n        ),\n      );\n      this.uninstallHandlers.push(\n        overrideContextMenuItemForShortcutText(\n          'commentDuplicate',\n          Constants.SHORTCUT_NAMES.DUPLICATE,\n        ),\n      );\n    }\n  }\n\n  /**\n   * Unregister the shortcut and reinstate the original context menu entries.\n   */\n  uninstall() {\n    this.uninstallHandlers.forEach((handler) => handler());\n    this.uninstallHandlers.length = 0;\n    if (this.duplicateShortcut) {\n      ShortcutRegistry.registry.unregister(this.duplicateShortcut.name);\n    }\n  }\n\n  /**\n   * Create and register the keyboard shortcut for the duplicate action.\n   * Same behaviour as for the core context menu.\n   * Skipped if there is a shortcut with a matching name already.\n   */\n  private registerDuplicateShortcut(): ShortcutRegistry.KeyboardShortcut | null {\n    if (\n      ShortcutRegistry.registry.getRegistry()[\n        Constants.SHORTCUT_NAMES.DUPLICATE\n      ]\n    ) {\n      return null;\n    }\n\n    const shortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.DUPLICATE,\n      // Equivalent to the core context menu entry.\n      preconditionFn(workspace, scope) {\n        const {focusedNode} = scope;\n        if (focusedNode instanceof BlockSvg) {\n          return (\n            !focusedNode.isInFlyout &&\n            focusedNode.isDeletable() &&\n            focusedNode.isMovable() &&\n            focusedNode.isDuplicatable()\n          );\n        } else if (focusedNode instanceof comments.RenderedWorkspaceComment) {\n          return focusedNode.isMovable();\n        }\n        return false;\n      },\n      callback(workspace, e, shortcut, scope) {\n        const copyable = scope.focusedNode as ICopyable<ICopyData>;\n        const data = copyable.toCopyData();\n        if (!data) return false;\n        return !!clipboard.paste(data, workspace);\n      },\n      keyCodes: [utils.KeyCodes.D],\n    };\n    ShortcutRegistry.registry.register(shortcut);\n    return shortcut;\n  }\n}\n\n/**\n * Replace a context menu item to add shortcut text to its displayText.\n *\n * Nothing happens if there is not a matching context menu item registered.\n *\n * @param registryId Context menu registry id to replace if present.\n * @param shortcutName The corresponding shortcut name.\n * @returns A function to reinstate the original context menu entry.\n */\nfunction overrideContextMenuItemForShortcutText(\n  registryId: string,\n  shortcutName: string,\n): () => void {\n  const original = ContextMenuRegistry.registry.getItem(registryId);\n  if (!original || 'separator' in original) {\n    return () => {};\n  }\n\n  const override: ContextMenuRegistry.RegistryItem = {\n    ...original,\n    displayText: (scope: ContextMenuRegistry.Scope) => {\n      const displayText =\n        typeof original.displayText === 'function'\n          ? original.displayText(scope)\n          : original.displayText;\n      if (displayText instanceof HTMLElement) {\n        // We can't cope in this scenario.\n        return displayText;\n      }\n      return getMenuItem(displayText, shortcutName);\n    },\n  };\n  ContextMenuRegistry.registry.unregister(registryId);\n  ContextMenuRegistry.registry.register(override);\n\n  return () => {\n    ContextMenuRegistry.registry.unregister(registryId);\n    ContextMenuRegistry.registry.register(original);\n  };\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport {ShortcutRegistry, WorkspaceSvg, utils} from 'blockly/core';\nimport * as Constants from '../constants';\n\n/**\n * Class for registering a shortcut for quick movement between top level bounds\n * in the workspace.\n */\nexport class StackNavigationAction {\n  private stackShortcuts: ShortcutRegistry.KeyboardShortcut[] = [];\n\n  install() {\n    const preconditionFn = (workspace: WorkspaceSvg) =>\n      !!getCurNodeRoot(workspace);\n\n    function getCurNodeRoot(workspace: WorkspaceSvg) {\n      const cursor = workspace.getCursor();\n      // The fallback case includes workspace comments.\n      return cursor.getSourceBlock()?.getRootBlock() ?? cursor.getCurNode();\n    }\n\n    const previousStackShortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.PREVIOUS_STACK,\n      preconditionFn,\n      callback: (workspace) => {\n        const curNodeRoot = getCurNodeRoot(workspace);\n        if (!curNodeRoot) return false;\n        const prevRoot = workspace\n          .getNavigator()\n          .getPreviousSibling(curNodeRoot);\n        if (!prevRoot) return false;\n        workspace.getCursor().setCurNode(prevRoot);\n        return true;\n      },\n      keyCodes: [utils.KeyCodes.B],\n    };\n\n    const nextStackShortcut: ShortcutRegistry.KeyboardShortcut = {\n      name: Constants.SHORTCUT_NAMES.NEXT_STACK,\n      preconditionFn,\n      callback: (workspace) => {\n        const curNodeRoot = getCurNodeRoot(workspace);\n        if (!curNodeRoot) return false;\n        const nextRoot = workspace.getNavigator().getNextSibling(curNodeRoot);\n        if (!nextRoot) return false;\n        workspace.getCursor().setCurNode(nextRoot);\n        return true;\n      },\n      keyCodes: [utils.KeyCodes.N],\n    };\n\n    ShortcutRegistry.registry.register(previousStackShortcut);\n    this.stackShortcuts.push(previousStackShortcut);\n    ShortcutRegistry.registry.register(nextStackShortcut);\n    this.stackShortcuts.push(nextStackShortcut);\n  }\n\n  /**\n   * Unregisters the shortcut.\n   */\n  uninstall() {\n    this.stackShortcuts.forEach((shortcut) =>\n      ShortcutRegistry.registry.unregister(shortcut.name),\n    );\n    this.stackShortcuts.length = 0;\n  }\n}\n","/**\n * @license\n * Copyright 2021 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\n/**\n * @fileoverview Registers all of the keyboard shortcuts that are necessary for\n * navigating blockly using the keyboard.\n * @author aschmiedt@google.com (Abby Schmiedt)\n */\n\nimport './toolbox_monkey_patch';\n\nimport * as Blockly from 'blockly/core';\nimport {\n  ShortcutRegistry,\n  Toolbox,\n  utils as BlocklyUtils,\n  WorkspaceSvg,\n  keyboardNavigationController,\n} from 'blockly/core';\n\nimport * as Constants from './constants';\nimport {Clipboard} from './actions/clipboard';\nimport {DeleteAction} from './actions/delete';\nimport {EditAction} from './actions/edit';\nimport {Navigation} from './navigation';\nimport {ShortcutDialog} from './shortcut_dialog';\nimport {WorkspaceMovement} from './actions/ws_movement';\nimport {ArrowNavigation} from './actions/arrow_navigation';\nimport {ExitAction} from './actions/exit';\nimport {EnterAction} from './actions/enter';\nimport {DisconnectAction} from './actions/disconnect';\nimport {ActionMenu} from './actions/action_menu';\nimport {MoveActions} from './actions/move';\nimport {Mover} from './actions/mover';\nimport {DuplicateAction} from './actions/duplicate';\nimport {StackNavigationAction} from './actions/stack_navigation';\n\nconst KeyCodes = BlocklyUtils.KeyCodes;\n\n/**\n * Class for registering shortcuts for keyboard navigation.\n */\nexport class NavigationController {\n  private navigation: Navigation = new Navigation();\n\n  private mover = new Mover(this.navigation);\n\n  shortcutDialog: ShortcutDialog = new ShortcutDialog();\n\n  /** Context menu and keyboard action for deletion. */\n  deleteAction: DeleteAction = new DeleteAction();\n\n  /** Context menu and keyboard action for deletion. */\n  editAction: EditAction = new EditAction(this.navigation);\n\n  /** Keyboard shortcut for disconnection. */\n  disconnectAction: DisconnectAction = new DisconnectAction(this.navigation);\n\n  clipboard: Clipboard;\n\n  duplicateAction = new DuplicateAction();\n\n  workspaceMovement: WorkspaceMovement = new WorkspaceMovement(this.navigation);\n\n  /** Keyboard navigation actions for the arrow keys. */\n  arrowNavigation: ArrowNavigation = new ArrowNavigation(this.navigation);\n\n  exitAction: ExitAction = new ExitAction(this.navigation);\n\n  enterAction: EnterAction = new EnterAction(this.mover, this.navigation);\n\n  actionMenu: ActionMenu = new ActionMenu(this.navigation);\n\n  moveActions = new MoveActions(this.mover);\n\n  stackNavigationAction: StackNavigationAction = new StackNavigationAction();\n\n  constructor(\n    private options: {allowCrossWorkspacePaste: boolean} = {\n      allowCrossWorkspacePaste: false,\n    },\n  ) {\n    this.clipboard = new Clipboard(this.navigation, options);\n  }\n\n  /**\n   * Original Toolbox.prototype.onShortcut method, saved by\n   * addShortcutHandlers.\n   */\n  private origToolboxOnShortcut:\n    | typeof Blockly.Toolbox.prototype.onShortcut\n    | null = null;\n\n  /**\n   * Registers the default keyboard shortcuts for keyboard navigation.\n   */\n  init() {\n    this.addShortcutHandlers();\n    this.registerDefaults();\n  }\n\n  /**\n   * Monkeypatches core Blockly components to add methods that allow\n   * them to handle keyboard shortcuts when in keyboard navigation\n   * mode.\n   */\n  protected addShortcutHandlers() {\n    this.origToolboxOnShortcut = Toolbox.prototype.onShortcut;\n    Toolbox.prototype.onShortcut = this.toolboxHandler;\n  }\n\n  /**\n   * Removes monkeypatches from core Blockly components.\n   */\n  protected removeShortcutHandlers() {\n    if (!this.origToolboxOnShortcut) {\n      throw new Error('no original onShortcut method recorded');\n    }\n    Blockly.Toolbox.prototype.onShortcut = this.origToolboxOnShortcut;\n    this.origToolboxOnShortcut = null;\n  }\n\n  /**\n   * Handles the given keyboard shortcut.\n   * This is only triggered when keyboard accessibility mode is enabled.\n   *\n   * @param shortcut The shortcut to be handled.\n   * @returns True if the toolbox handled the shortcut, false otherwise.\n   */\n  protected toolboxHandler(\n    this: Blockly.Toolbox,\n    shortcut: ShortcutRegistry.KeyboardShortcut,\n  ): boolean {\n    if (!this.selectedItem_) {\n      return false;\n    }\n    switch (shortcut.name) {\n      case Constants.SHORTCUT_NAMES.UP:\n        // @ts-expect-error private method\n        return this.selectPrevious();\n      case Constants.SHORTCUT_NAMES.LEFT:\n        // @ts-expect-error private method\n        return this.selectParent();\n      case Constants.SHORTCUT_NAMES.DOWN:\n        // @ts-expect-error private method\n        return this.selectNext();\n      case Constants.SHORTCUT_NAMES.RIGHT:\n        // @ts-expect-error private method\n        return this.selectChild();\n      default:\n        return false;\n    }\n  }\n\n  /**\n   * Adds all necessary event listeners and markers to a workspace for keyboard\n   * navigation to work. This must be called for keyboard navigation to work\n   * on a workspace.\n   *\n   * @param workspace The workspace to add keyboard\n   *     navigation to.\n   */\n  addWorkspace(workspace: WorkspaceSvg) {\n    this.navigation.addWorkspace(workspace);\n  }\n\n  /**\n   * Removes all necessary event listeners and markers to a workspace for\n   * keyboard navigation to work.\n   *\n   * @param workspace The workspace to remove keyboard\n   *     navigation from.\n   */\n  removeWorkspace(workspace: WorkspaceSvg) {\n    this.navigation.removeWorkspace(workspace);\n  }\n\n  /**\n   * Turns on keyboard navigation.\n   *\n   * @param workspace The workspace to turn on keyboard\n   *     navigation for.\n   */\n  enable(workspace: WorkspaceSvg) {\n    this.navigation.enableKeyboardAccessibility(workspace);\n  }\n\n  /**\n   * Turns off keyboard navigation.\n   *\n   * @param workspace The workspace to turn off keyboard\n   *     navigation on.\n   */\n  disable(workspace: WorkspaceSvg) {\n    this.navigation.disableKeyboardAccessibility(workspace);\n  }\n\n  /**\n   * Dictionary of KeyboardShortcuts.\n   */\n  protected shortcuts: {\n    [name: string]: ShortcutRegistry.KeyboardShortcut;\n  } = {\n    /** Move focus to or from the toolbox. */\n    focusToolbox: {\n      name: Constants.SHORTCUT_NAMES.TOOLBOX,\n      preconditionFn: (workspace) => !workspace.isDragging(),\n      callback: (workspace) => {\n        keyboardNavigationController.setIsActive(true);\n        switch (this.navigation.getState()) {\n          case Constants.STATE.WORKSPACE:\n            Blockly.getFocusManager().focusTree(\n              workspace.getToolbox() ??\n                workspace.getFlyout()?.getWorkspace() ??\n                workspace,\n            );\n            return true;\n          default:\n            return false;\n        }\n      },\n      keyCodes: [KeyCodes.T],\n    },\n\n    /** Clean up the workspace. */\n    cleanup: {\n      name: Constants.SHORTCUT_NAMES.CLEAN_UP,\n      preconditionFn: (workspace) =>\n        this.navigation.canCurrentlyEdit(workspace) &&\n        workspace.getTopBlocks(false).length > 0,\n      callback: (workspace) => {\n        workspace.cleanUp();\n        return true;\n      },\n      keyCodes: [KeyCodes.C],\n    },\n  };\n\n  /**\n   * Registers all default keyboard shortcut items for keyboard\n   * navigation. This should be called once per instance of\n   * KeyboardShortcutRegistry.\n   */\n  protected registerDefaults() {\n    for (const shortcut of Object.values(this.shortcuts)) {\n      ShortcutRegistry.registry.register(shortcut);\n    }\n    this.deleteAction.install();\n    this.workspaceMovement.install();\n    this.arrowNavigation.install();\n    this.editAction.install();\n    this.exitAction.install();\n    this.enterAction.install();\n    this.disconnectAction.install();\n    this.actionMenu.install();\n\n    this.clipboard.install();\n    this.duplicateAction.install();\n    this.moveActions.install();\n    this.shortcutDialog.install();\n    this.stackNavigationAction.install();\n\n    // Initialize the shortcut modal with available shortcuts.  Needs\n    // to be done separately rather at construction, as many shortcuts\n    // are not registered at that point.\n    this.shortcutDialog.createModalContent();\n  }\n\n  /**\n   * Removes all the keyboard navigation shortcuts.\n   */\n  dispose() {\n    this.moveActions.uninstall();\n    this.deleteAction.uninstall();\n    this.editAction.uninstall();\n    this.disconnectAction.uninstall();\n    this.clipboard.uninstall();\n    this.duplicateAction.uninstall();\n    this.workspaceMovement.uninstall();\n    this.arrowNavigation.uninstall();\n    this.exitAction.uninstall();\n    this.enterAction.uninstall();\n    this.actionMenu.uninstall();\n    this.shortcutDialog.uninstall();\n    this.stackNavigationAction.uninstall();\n\n    for (const shortcut of Object.values(this.shortcuts)) {\n      ShortcutRegistry.registry.unregister(shortcut.name);\n    }\n    this.removeShortcutHandlers();\n    this.navigation.dispose();\n  }\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\nconst lastBlockDisabledReasons: Map<string, Set<string>> = new Map();\n\n/**\n * A change listener that enables disabled blocks when they\n * are dragged, and re-disables them at the end of the drag.\n *\n * @param event Blockly event\n */\nexport function enableBlocksOnDrag(event: Blockly.Events.Abstract) {\n  // This listener only runs on Drag events that have a valid\n  // workspace and block id.\n  if (!isBlockDrag(event)) return;\n  if (!event.blockId) return;\n  const eventWorkspace = Blockly.common.getWorkspaceById(\n    event.workspaceId,\n  ) as Blockly.WorkspaceSvg;\n  const block = eventWorkspace.getBlockById(event.blockId);\n  if (!block) return;\n\n  const oldUndo = Blockly.Events.getRecordUndo();\n  Blockly.Events.setRecordUndo(false);\n\n  if (event.isStart) {\n    // At start of drag, reset the lastBlockDisabledReasons\n    lastBlockDisabledReasons.clear();\n\n    // Enable all blocks including childeren\n    enableAllDraggedBlocks(block);\n  } else {\n    // Re-disable the block for its original reasons. If the block is no\n    // longer an orphan, the disableOrphans handler will enable the block.\n    redisableAllDraggedBlocks(block);\n  }\n\n  Blockly.Events.setRecordUndo(oldUndo);\n}\n\n/**\n * Enables all blocks including children of the dragged blocks.\n * Stores the reasons each block was disabled so they can be restored.\n *\n * @param block\n */\nfunction enableAllDraggedBlocks(block: Blockly.BlockSvg) {\n  // getDescendants includes the block itself.\n  block.getDescendants(false).forEach((descendant) => {\n    const reasons = new Set(descendant.getDisabledReasons());\n    lastBlockDisabledReasons.set(descendant.id, reasons);\n    reasons.forEach((reason) => descendant.setDisabledReason(false, reason));\n  });\n}\n\n/**\n * Re-disables all blocks using their original disabled reasons.\n *\n * @param block\n */\nfunction redisableAllDraggedBlocks(block: Blockly.BlockSvg) {\n  block.getDescendants(false).forEach((descendant) => {\n    lastBlockDisabledReasons.get(descendant.id)?.forEach((reason) => {\n      descendant.setDisabledReason(true, reason);\n    });\n  });\n}\n\n/**\n * Type guard for drag events.\n *\n * @param event\n * @returns true iff event.type is EventType.BLOCK_DRAG\n */\nfunction isBlockDrag(\n  event: Blockly.Events.Abstract,\n): event is Blockly.Events.BlockDrag {\n  return event.type === Blockly.Events.BLOCK_DRAG;\n}\n","/**\n * @license\n * Copyright 2025 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\n\n/**\n * Configuration options for toasts.\n */\ninterface HtmlToastOptions extends Blockly.ToastOptions {\n  element?: HTMLElement;\n}\n\n/**\n * Custom toast implementation that supports HTML elements in toast messages.\n *\n * After registering, call \n  `Blockly.dialog.toast(workspace, {element: <html element>, message: <text>});`\n * to display an HTML-based toast.\n */\nclass HtmlToast extends Blockly.Toast {\n  /**\n   * Creates the body of the toast for display.\n   *\n   * @param workspace The workspace the toast will be displayed on.\n   * @param options Configuration options for toast appearance/behavior.\n   * @returns The body for the toast.\n   */\n  protected static override createDom(\n    workspace: Blockly.WorkspaceSvg,\n    options: HtmlToastOptions,\n  ) {\n    const dom = super.createDom(workspace, options);\n    const contents = dom.querySelector('div');\n    if (\n      contents &&\n      'element' in options &&\n      options.element instanceof HTMLElement\n    ) {\n      contents.innerHTML = '';\n      contents.appendChild(options.element);\n    }\n    return dom;\n  }\n}\n\n/**\n * Registers HtmlToast as the default toast implementation for Blockly.\n */\nexport function registerHtmlToast() {\n  Blockly.dialog.setToast(HtmlToast.show.bind(HtmlToast));\n}\n","/**\n * @license\n * Copyright 2024 Google LLC\n * SPDX-License-Identifier: Apache-2.0\n */\n\nimport * as Blockly from 'blockly/core';\nimport {NavigationController} from './navigation_controller';\nimport {enableBlocksOnDrag} from './disabled_blocks';\nimport {registerHtmlToast} from './html_toast';\n\n/** Plugin for keyboard navigation. */\nexport class KeyboardNavigation {\n  /** The workspace. */\n  protected workspace: Blockly.WorkspaceSvg;\n\n  /** Keyboard navigation controller instance for the workspace. */\n  private navigationController: NavigationController;\n\n  /** Cursor for the main workspace. */\n  private cursor: Blockly.LineCursor;\n\n  /**\n   * Focus ring in the workspace.\n   */\n  private workspaceFocusRing: Element | null = null;\n\n  /**\n   * Selection ring inside the workspace.\n   */\n  private workspaceSelectionRing: Element | null = null;\n\n  /**\n   * Used to restore monkey patch.\n   */\n  private oldWorkspaceResize:\n    | InstanceType<typeof Blockly.WorkspaceSvg>['resize']\n    | null = null;\n\n  /**\n   * Constructs the keyboard navigation.\n   *\n   * @param workspace The workspace that the plugin will be added to.\n   * @param options Options for plugin\n   * @param options.allowCrossWorkspacePaste If true, will allow paste\n   * option to appear enabled when pasting in a different workspace\n   * than was copied from. Defaults to false. Set to true if using\n   * cross-tab-copy-paste plugin or similar.\n   */\n  constructor(\n    workspace: Blockly.WorkspaceSvg,\n    options: {allowCrossWorkspacePaste: boolean} = {\n      allowCrossWorkspacePaste: false,\n    },\n  ) {\n    this.workspace = workspace;\n\n    this.navigationController = new NavigationController(options);\n    this.navigationController.init();\n    this.navigationController.addWorkspace(workspace);\n    this.navigationController.enable(workspace);\n\n    this.cursor = new Blockly.LineCursor(workspace);\n\n    // Add the event listener to enable disabled blocks on drag.\n    workspace.addChangeListener(enableBlocksOnDrag);\n\n    // Move the flyout for logical tab order.\n    const flyout = workspace.getFlyout();\n    if (flyout != null && flyout instanceof Blockly.Flyout) {\n      // This relies on internals.\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      const flyoutElement = ((flyout as any).svgGroup_ as SVGElement) ?? null;\n      flyoutElement?.parentElement?.insertBefore(\n        flyoutElement,\n        workspace.getParentSvg(),\n      );\n    }\n\n    this.oldWorkspaceResize = workspace.resize;\n    workspace.resize = () => {\n      this.oldWorkspaceResize?.call(this.workspace);\n      this.resizeWorkspaceRings();\n    };\n    this.workspaceSelectionRing = Blockly.utils.dom.createSvgElement('rect', {\n      fill: 'none',\n      class: 'blocklyWorkspaceSelectionRing',\n    });\n    workspace.getSvgGroup().appendChild(this.workspaceSelectionRing);\n    this.workspaceFocusRing = Blockly.utils.dom.createSvgElement('rect', {\n      fill: 'none',\n      class: 'blocklyWorkspaceFocusRing',\n    });\n    workspace.getSvgGroup().appendChild(this.workspaceFocusRing);\n    this.resizeWorkspaceRings();\n\n    registerHtmlToast();\n  }\n\n  private resizeWorkspaceRings() {\n    if (!this.workspaceFocusRing || !this.workspaceSelectionRing) return;\n    this.resizeFocusRingInternal(this.workspaceSelectionRing, 5);\n    this.resizeFocusRingInternal(this.workspaceFocusRing, 0);\n  }\n\n  private resizeFocusRingInternal(ring: Element, inset: number) {\n    const metrics = this.workspace.getMetrics();\n    ring.setAttribute('x', (metrics.absoluteLeft + inset).toString());\n    ring.setAttribute('y', (metrics.absoluteTop + inset).toString());\n    ring.setAttribute(\n      'width',\n      Math.max(0, metrics.viewWidth - inset * 2).toString(),\n    );\n    ring.setAttribute(\n      'height',\n      Math.max(0, metrics.svgHeight - inset * 2).toString(),\n    );\n  }\n\n  /**\n   * Disables keyboard navigation for this navigator's workspace.\n   */\n  dispose() {\n    this.workspaceFocusRing?.remove();\n    this.workspaceSelectionRing?.remove();\n    if (this.oldWorkspaceResize) {\n      this.workspace.resize = this.oldWorkspaceResize;\n    }\n\n    // Remove the event listener that enables blocks on drag\n    this.workspace.removeChangeListener(enableBlocksOnDrag);\n    this.navigationController.dispose();\n  }\n\n  /**\n   * Toggle visibility of a help dialog for the keyboard shortcuts.\n   */\n  toggleShortcutDialog(): void {\n    this.navigationController.shortcutDialog.toggle(this.workspace);\n  }\n\n  /**\n   * Register CSS used by the plugin.\n   * This is broken up into sections by purpose, with some notes about\n   * where it should eventually live.\n   * Must be called before `Blockly.inject`.\n   */\n  static registerKeyboardNavigationStyles() {\n    // Enable the delete icon for comments.\n    //\n    // This should remain in the plugin for the time being because we do\n    // not want to display the delete icon by default.\n    Blockly.Css.register(`\n  .blocklyDeleteIcon {\n    display: block;\n  }\n`);\n\n    // Set variables that will be used to control the appearance of the\n    // focus indicators.  Attach them to the injectionDiv since they will\n    // apply to things contained therein.\n    //\n    // This should be moved to core, either to core/css.ts\n    // or to core/renderers/.\n    Blockly.Css.register(`\n  .injectionDiv {\n    --blockly-active-node-color: #fff200;\n    --blockly-active-tree-color: #60a5fa;\n    --blockly-selection-width: 3px;\n  }\n`);\n\n    // Styling focusing blocks, connections and fields.\n    //\n    // This should be moved to core, being integrated into the\n    // existing styling of renderers in core/renderers/*/constants.ts.\n    //\n    // Many selectors include .blocklyKeyboardNavigation to ensure keyboard\n    // nav is on (via the heuristic). This class is added/removed from body.\n    Blockly.Css.register(`\n  /* Active focus cases: */\n  /* Blocks with active focus. */\n  .blocklyKeyboardNavigation\n    .blocklyActiveFocus:is(.blocklyPath, .blocklyHighlightedConnectionPath),\n  /* Fields with active focus, */\n  .blocklyKeyboardNavigation\n    .blocklyActiveFocus.blocklyField\n    > .blocklyFieldRect,\n  /* Icons with active focus. */\n  .blocklyKeyboardNavigation\n    .blocklyActiveFocus.blocklyIconGroup\n    > .blocklyIconShape:first-child {\n    stroke: var(--blockly-active-node-color);\n    stroke-width: var(--blockly-selection-width);\n  }\n\n  /* Passive focus cases: */\n  /* Blocks with passive focus except when widget/dropdown div in use. */\n  .blocklyKeyboardNavigation:not(\n          :has(\n              .blocklyDropDownDiv:focus-within,\n              .blocklyWidgetDiv:focus-within\n            )\n        )\n    .blocklyPassiveFocus:is(\n      .blocklyPath:not(.blocklyFlyout .blocklyPath),\n      .blocklyHighlightedConnectionPath\n    ),\n  /* Fields with passive focus except when widget/dropdown div in use. */\n  .blocklyKeyboardNavigation:not(\n          :has(\n              .blocklyDropDownDiv:focus-within,\n              .blocklyWidgetDiv:focus-within\n            )\n        )\n    .blocklyPassiveFocus.blocklyField\n    > .blocklyFieldRect,\n  /* Icons with passive focus except when widget/dropdown div in use. */\n  .blocklyKeyboardNavigation:not(\n          :has(\n              .blocklyDropDownDiv:focus-within,\n              .blocklyWidgetDiv:focus-within\n            )\n        )\n    .blocklyPassiveFocus.blocklyIconGroup\n    > .blocklyIconShape:first-child {\n    stroke: var(--blockly-active-node-color);\n    stroke-dasharray: 5px 3px;\n    stroke-width: var(--blockly-selection-width);\n  }\n\n  /* Workaround for unexpectedly hidden connection path due to core style. */\n  .blocklyKeyboardNavigation\n    .blocklyPassiveFocus.blocklyHighlightedConnectionPath {\n    display: unset !important;\n  }\n`);\n\n    // Styling for focusing the toolbox and flyout.\n    //\n    // This should be moved to core, to core/css.ts if not to somewhere\n    // more specific in core/toolbox/.\n    Blockly.Css.register(`\n  /* Different ways for toolbox/flyout to be the active tree: */\n  /* Active focus in the flyout. */\n  .blocklyKeyboardNavigation .blocklyFlyout:has(.blocklyActiveFocus),\n  /* Active focus in the toolbox. */\n  .blocklyKeyboardNavigation .blocklyToolbox:has(.blocklyActiveFocus),\n  /* Active focus on the toolbox/flyout. */\n  .blocklyKeyboardNavigation\n    .blocklyActiveFocus:is(.blocklyFlyout, .blocklyToolbox) {\n    outline-offset: calc(var(--blockly-selection-width) * -1);\n    outline: var(--blockly-selection-width) solid\n      var(--blockly-active-tree-color);\n  }\n\n  /* Suppress default outline. */\n  .blocklyKeyboardNavigation\n    .blocklyToolboxCategoryContainer:focus-visible {\n    outline: none;\n  }\n`);\n\n    // Styling for focusing the Workspace.\n    //\n    // This should be move to core, probably to core/css.ts.\n    Blockly.Css.register(`\n  /* Different ways for the workspace to be the active tree: */\n  /* Active focus within workspace. */\n  .blocklyKeyboardNavigation\n    .blocklyWorkspace:has(.blocklyActiveFocus)\n    .blocklyWorkspaceFocusRing,\n  /* Active focus within drag layer. */\n  .blocklyKeyboardNavigation\n    .blocklySvg:has(~ .blocklyBlockDragSurface .blocklyActiveFocus)\n    .blocklyWorkspaceFocusRing,\n  /* Active focus on workspace. */\n  .blocklyKeyboardNavigation\n    .blocklyWorkspace.blocklyActiveFocus\n    .blocklyWorkspaceFocusRing,\n  /* Focus in widget/dropdown div considered to be in workspace. */\n  .blocklyKeyboardNavigation:has(\n    .blocklyWidgetDiv:focus-within,\n    .blocklyDropDownDiv:focus-within\n  )\n    .blocklyWorkspace\n    .blocklyWorkspaceFocusRing {\n    stroke: var(--blockly-active-tree-color);\n    stroke-width: calc(var(--blockly-selection-width) * 2);\n  }\n\n  /* The workspace itself is the active node. */\n  .blocklyKeyboardNavigation\n    .blocklyWorkspace.blocklyActiveFocus\n    .blocklyWorkspaceSelectionRing {\n    stroke: var(--blockly-active-node-color);\n    stroke-width: var(--blockly-selection-width);\n  }\n`);\n\n    // Keyboard-nav-specific styling for the context menu.\n    //\n    // This should remain in the plugin for the time being because the\n    // classes selected are currently only defined in the plugin.\n    Blockly.Css.register(`\n  .blocklyRTL .blocklyMenuItemContent .blocklyShortcutContainer {\n    flex-direction: row-reverse;\n  }\n  .blocklyMenuItemContent .blocklyShortcutContainer {\n    width: 100%;\n    display: flex;\n    justify-content: space-between;\n    gap: 16px;\n  }\n  .blocklyMenuItemContent .blocklyShortcutContainer .blocklyShortcut {\n    color: #ccc;\n  }\n`);\n  }\n}\n"],"names":["root","factory","exports","module","require","define","amd","a","i","this","__WEBPACK_EXTERNAL_MODULE__370__","__WEBPACK_EXTERNAL_MODULE__826__","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","__webpack_modules__","d","definition","key","o","Object","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","r","Symbol","toStringTag","value","STATE","SHORTCUT_NAMES","LOGGING_MSG_TYPE","onKeyDown_","SHORTCUT_CATEGORIES","Msg","MENU","EDIT_OR_CONFIRM","EXIT","TOOLBOX","CLEAN_UP","LIST_SHORTCUTS","INSERT","DISCONNECT","DUPLICATE","UP","DOWN","RIGHT","LEFT","NEXT_STACK","PREVIOUS_STACK","keyNames","isMacPlatform","navigator","platform","startsWith","getMenuItem","labelText","action","indexOf","length","split","container","document","createElement","className","label","textContent","shortcut","getShortActionShortcut","appendChild","getActionShortcutsAsKeys","shortModifierNames","join","longModifierNames","modifierNames","named","ShortcutRegistry","registry","getKeyCodesByShortcutName","map","maybeNumeric","k","upperCaseFirst","command","option","control","sort","b","aValue","includes","currentPlatform","filter","some","str","charAt","toUpperCase","substring","unconstrainedMoveHintId","constrainedMoveHintId","copiedHintId","cutHintId","helpHintId","showUnconstrainedMoveHint","workspace","force","enter","message","Toast","show","id","oncePerSession","Clipboard","constructor","navigation","options","allowCrossWorkspacePaste","install","registerCopyShortcut","registerCopyContextMenuAction","registerPasteShortcut","registerPasteContextMenuAction","registerCutShortcut","registerCutContextMenuAction","uninstall","ContextMenuRegistry","unregister","CUT","COPY","PASTE","oldCutShortcut","getRegistry","ShortcutItems","names","Error","cutShortcut","name","preconditionFn","callback","cutCallback","bind","keyCodes","allowCollision","register","cutAction","displayText","scope","cutPrecondition","menuOpenEvent","isCopyable","focusedNode","ws","WorkspaceSvg","weight","focused","e","didCut","duration","showCutHint","oldCopyShortcut","copyShortcut","copyCallback","copyAction","copyPrecondition","BASE_WEIGHT","didCopy","showCopiedHint","oldPasteShortcut","pasteShortcut","pasteCallback","pasteAction","pastePrecondition","getPasteWorkspace","isSelectable","isFlyout","copiedWorkspace","clipboard","getLastCopiedWorkspace","targetWorkspace","didPaste","hide","clearPasteHints","DeleteAction","oldDisplayText","oldContextMenuItem","registerContextMenuAction","getItem","result","HTMLElement","innerText","DELETE","EditAction","editAboveItem","PointerEvent","block","canCurrentlyNavigate","cursor","getCursor","atEndOfLine","keyboardNavigationController","setIsActive","in","scopeType","ScopeType","BLOCK","FlyoutCursor","flyout","super","getWorkspace","next","curNode","getCurNode","newNode","getNavigator","getNextSibling","setCurNode","prev","getPreviousSibling","node","bounds","getBoundingRectangle","x","y","getPosition","Rect","height","width","inProgress","scale","getScale","rawViewport","getMetricsManager","getViewMetrics","viewport","top","left","right","bottom","clone","deltaX","deltaY","scroll","scrollX","scrollY","scrollBoundsIntoView","registrationType","Type","CURSOR","registrationName","toString","Navigation","workspaces","wsChangeWrapper","workspaceChangeListener","flyoutChangeWrapper","flyoutChangeListener","addWorkspace","push","getFlyout","addChangeListener","addFlyout","removeWorkspace","workspaceIdx","disableKeyboardAccessibility","splice","removeChangeListener","removeFlyout","getState","focusManager","ephemeralFocusTaken","NOWHERE","focusedTree","getFocusedTree","FLYOUT","WORKSPACE","flyoutWorkspace","FlyoutCursorClass","getClass","getMarkerManager","setCursor","workspaceId","getById","keyboardAccessibilityMode","type","BLOCK_CHANGE","element","handleBlockMutation","mainWorkspace","autoClose","CLICK","targetType","blockId","getBlockById","handleBlockClickInFlyout","SELECTED","newElementId","BLOCK_CREATE","defaultFlyoutCursorIfNeeded","isFlyoutItemDisposed","sourceBlock","disposed","getSvgRoot","parentNode","mutatedBlockId","getSourceBlock","curNodeBlock","isShadow","getParent","getFlyoutCursor","focusTree","prefer","flyoutCursor","getFocusableTree","flyoutContents","getContents","defaultFlyoutItem","defaultFlyoutItemElement","getElement","defaultWorkspaceCursorPositionIfNeeded","topBlocks","getTopBlocks","findInsertStartPoint","stationaryNode","movingBlock","movingHasOutput","outputConnection","INPUT_VALUE","inputType","inputTypes","VALUE","STATEMENT","compatibleInputs","inputList","input","connection","targetBlock","nextConnection","target","targetConnection","parent","warn","tryToConnectBlock","destConnection","insertBlock","disconnectChild","movingConnection","destBlock","inferiorConnection","getRootBlock","getDescendants","getInferiorConnection","disconnect","connect","movingInferior","destSuperior","getSuperiorConnection","movingSuperior","destInferior","moveAndConnect","checker","getConnectionChecker","reason","canConnectWithReason","getErrorMessage","isSuperior","previousConnection","canConnect","rootBlock","originalOffsetToTarget","originalOffsetInBlock","getOffsetInBlock","positionNearConnection","inputConnection","enableKeyboardAccessibility","log","msg","console","error","openToolboxOrFlyout","toolbox","getToolbox","paste","copyData","targetNode","setGroup","getRootWorkspace","canCurrentlyEdit","isReadOnly","dispose","ShortcutDialog","outputDiv","getElementById","open","modalContainer","shortcutDialog","closeButton","getPlatform","userAgent","test","updatePlatformName","platformEl","querySelector","toggle","clearHelpHint","toggleInternal","hasAttribute","close","showModal","getReadableShortcutName","shortcutName","replace","createModalContent","modalContents","categoryShortcuts","entries","keyboardShortcut","actionShortcutsToHTML","innerHTML","addEventListener","shortcuts","getLongActionShortcutsAsKeys","keys","actionShortcutToHTML","separator","index","announceShortcut","KeyCodes","SLASH","createSerializedKey","WorkspaceMovement","MOVE_WS_CURSOR_LEFT","moveWSCursor","A","SHIFT","MOVE_WS_CURSOR_RIGHT","D","MOVE_WS_CURSOR_UP","W","MOVE_WS_CURSOR_DOWN","S","CREATE_WS_CURSOR","createWSCursor","xDirection","yDirection","ArrowNavigation","fieldShortcutHandler","Field","onShortcut","navigateIn","isHandled","selectChild","navigateOut","out","selectParent","RTL","down","getSelectedItem","selectNext","firstItem","getToolboxItems","find","item","setSelectedItem","selectedItem","focusNode","up","selectPrevious","values","ExitAction","getFocusManager","Gesture","hideChaff","isMutator","parentWorkspace","getAllBlocks","getIcons","flat","icon","icons","MutatorIcon","bubbleIsVisible","getBubble","setBubbleVisible","ESC","Direction","getXYFromDirection","dir","Up","Down","Left","Right","MoveIndicatorBubble","sourceElement","location","Coordinate","svgRoot","dom","createSvgElement","Svg","G","getBubbleCanvas","rtl","CIRCLE","PATH","updateLocation","isMovable","getBoundingRectangleWithoutChildren","moveTo","getLayerManager","moveToDragLayer","setAttribute","getRelativeToSurfaceXY","removeNode","showContextMenu","setDragging","dragging","startDrag","event","drag","newLocation","moveDuringDrag","endDrag","revertDrag","setDeleteStyle","enable","getFocusableElement","onNodeFocus","onNodeBlur","canBeFocused","MoveIcon","moveIndicator","getType","getWeight","getSize","Size","isShownWhenCollapsed","isClickableInFlyout","onLocationChange","blockOrigin","applyColour","hideForInsertionMarker","updateEditable","updateCollapsed","setOffsetInBlock","onClick","visible","initView","pointerDownListener","IconType","KeyboardDragStrategy","BlockDragStrategy","moveType","startPoint","currentDragDirection","searchNode","startLoc","connectionCandidate","createInitialCandidate","forceShowPreview","addIcon","newLoc","xy","getDirectionFromXY","tiltX","tiltY","neighbour","isConstrainedMovement","utils","removeIcon","getConstrainedConnectionCandidate","draggingBlock","localConns","getLocalConnections","candidateConnection","findTraversalCandidate","findNearestCandidate","radius","Infinity","candidate","dxy","conn","rad","closest","local","distance","connectionChecker","potential","allConnections","topBlock","flatMap","getConnections_","delta","potentialIndex","forEach","currCandidateIsBetter","currCandidate","newCandidate","getConnectionCandidate","previewer","connectionPreviewer","localIsOutputOrPrevious","ConnectionType","OUTPUT_VALUE","PREVIOUS_STATEMENT","neighbourIsConnectedToRealBlock","isInsertionMarker","orphanCanConnectAtEnd","previewReplacement","previewConnection","startParentConn","NEXT_STATEMENT","shouldHealStack","Boolean","COMMIT_MOVE_SHORTCUT","MoveType","Mover","moves","Map","oldDragStrategy","canMove","draggable","has","isMoving","startMove","BlockSvg","patchDragStrategy","comments","RenderedWorkspaceComment","DraggerClass","getClassFromOptions","BLOCK_DRAGGER","dragger","blurListener","finishMove","setKeyboardMoveInProgress","info","MoveInfo","set","onDragStart","fakePointerEvent","updateTotalDelta","shortcutKeys","keyCode","ENTER","parseInt","pop","commitMoveShortcut","preDragEndCleanup","onDragEnd","postDragEndCleanup","abortMove","dragStrategy","patchDragger","startLocation","Insert","clearMoveHints","removeEventListener","unpatchDragStrategy","delete","setTimeout","scrollCurrentElementIntoView","moveConstrained","direction","moveUnconstrained","onDrag","totalDelta","setDragStrategy","padding","wouldDeleteDraggable","shouldReturnToStart","parentNext","parentInput","coordinates","svgMath","wsToScreenCoordinates","tilts","clientX","clientY","relativeCoords","EnterAction","mover","shouldHandleEnterForWS","preventDefault","handleEnterForWS","insertFromFlyout","FlyoutButton","triggerButtonCallback","SPACE","isClickable","RenderedConnection","Icon","CommentBarButton","showEditor","tryShowFullBlockFieldEditor","showHelpHint","renderManagement","finishQueuedRenders","then","performAction","setCollapsed","getEditorFocusableNode","setResizesEnabled","Events","getGroup","FocusableTreeTraverser","findFocusedNode","getRestoredFocusableNode","newBlock","createNewBlock","insertStartPoint","positionNewTopLevelBlock","showConstrainedMovementHint","allBlockBounds","toolboxWidth","getWidth","workspaceWidth","getParentSvg","clientWidth","newBlockHeight","newBlockWidth","clientHeight","getHeightWidth","getNextIntersectingBlock","newBlockRect","rect","intersects","cursorY","cursorX","minBlockHeight","getRenderer","getConstants","MIN_BLOCK_HEIGHT","boundingRect","moveBy","snapToGrid","conflictingRect","newCursorX","newCursorY","getHeight","bringToFront","button","flyoutButtonCallbacks","buttonCallback","callbackkey","isSimpleReporter","field","fieldRow","isFullBlockField","isVisible","curBlock","isEnabled","createBlock","render","setConnectionTracking","DisconnectAction","registerShortcut","disconnectShortcut","disconnectBlocks","X","healStack","isConnected","unplug","ActionMenu","menuShortcut","isDragging","openActionMenu","CTRL","ALT","META","KeyboardEvent","WidgetDiv","getDiv","dispatchEvent","code","which","bubbles","cancelable","MoveActions","shortcutNames","menuItemNames","registerShortcuts","startDraggable","getCurrentDraggable","Move","M","registerMenuItems","menuItems","comment","COMMENT","menuItem","getFocusedNode","DuplicateAction","duplicateShortcut","uninstallHandlers","registerDuplicateShortcut","overrideContextMenuItemForShortcutText","handler","isInFlyout","isDeletable","isDuplicatable","data","toCopyData","registryId","original","override","StackNavigationAction","stackShortcuts","getCurNodeRoot","previousStackShortcut","curNodeRoot","prevRoot","B","nextStackShortcut","nextRoot","N","NavigationController","deleteAction","editAction","disconnectAction","duplicateAction","workspaceMovement","arrowNavigation","exitAction","enterAction","actionMenu","moveActions","stackNavigationAction","origToolboxOnShortcut","focusToolbox","T","cleanup","cleanUp","C","init","addShortcutHandlers","registerDefaults","Toolbox","toolboxHandler","removeShortcutHandlers","selectedItem_","disable","lastBlockDisabledReasons","enableBlocksOnDrag","BLOCK_DRAG","isBlockDrag","getWorkspaceById","oldUndo","getRecordUndo","setRecordUndo","isStart","clear","descendant","reasons","Set","getDisabledReasons","setDisabledReason","enableAllDraggedBlocks","redisableAllDraggedBlocks","HtmlToast","createDom","contents","KeyboardNavigation","workspaceFocusRing","workspaceSelectionRing","oldWorkspaceResize","navigationController","flyoutElement","svgGroup_","parentElement","insertBefore","resize","resizeWorkspaceRings","fill","class","getSvgGroup","setToast","resizeFocusRingInternal","ring","inset","metrics","getMetrics","absoluteLeft","absoluteTop","Math","max","viewWidth","svgHeight","remove","toggleShortcutDialog","registerKeyboardNavigationStyles"],"sourceRoot":""}