/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import type { IDragger, RenderedConnection, IDraggable, IFocusableNode, IBoundedElement, ISelectable } from 'blockly';
import { Connection, utils, WorkspaceSvg } from 'blockly';
import { Direction } from '../drag_direction';
import { Navigation } from '../navigation';
/**
 * Whether this is an insert or a move.
 */
export declare enum MoveType {
    /**
     * An insert will remove the block if the move is aborted.
     */
    Insert = 0,
    /**
     * A regular move of a pre-existing block.
     */
    Move = 1
}
/**
 * Low-level code for moving elements with keyboard shortcuts.
 */
export declare class Mover {
    protected navigation: Navigation;
    /**
     * Map of moves in progress.
     *
     * An entry for a given workspace in this map means that the this
     * Mover is moving an element on that workspace, and will disable
     * normal cursor movement until the move is complete.
     */
    protected moves: Map<WorkspaceSvg, MoveInfo>;
    /**
     * The element's base drag strategy, which will be overridden during
     * keyboard drags and reset at the end of the drag.
     */
    private oldDragStrategy;
    private moveIndicator?;
    constructor(navigation: Navigation);
    /**
     * Returns true iff we are able to begin moving the draggable element which
     * currently has focus on the given workspace.
     *
     * @param workspace The workspace to move on.
     * @param draggable The draggable element to try to drag.
     * @returns True iff we can begin a move.
     */
    canMove(workspace: WorkspaceSvg, draggable: IDraggable): boolean;
    /**
     * Returns true iff we are currently moving an element on the given
     * workspace.
     *
     * @param workspace The workspace we might be moving on.
     * @returns True iff we are moving.
     */
    isMoving(workspace: WorkspaceSvg): boolean;
    /**
     * Start moving the currently-focused item on workspace, if
     * possible.
     *
     * Should only be called if canMove has returned true.
     *
     * @param workspace The workspace we might be moving on.
     * @param draggable The element to start dragging.
     * @param moveType Whether this is an insert or a move.
     * @param startPoint Where to start the move, or null to use the current
     *     location if any.
     * @returns True iff a move has successfully begun.
     */
    startMove(workspace: WorkspaceSvg, draggable: IDraggable & IFocusableNode & IBoundedElement & ISelectable, moveType: MoveType, startPoint: RenderedConnection | null): boolean;
    /**
     * Finish moving the currently-focused item on workspace.
     *
     * Should only be called if isMoving has returned true.
     *
     * @param workspace The workspace on which we are moving.
     * @returns True iff move successfully finished.
     */
    finishMove(workspace: WorkspaceSvg): boolean;
    /**
     * Abort moving the currently-focused item on workspace.
     *
     * Should only be called if isMoving has returned true.
     *
     * @param workspace The workspace on which we are moving.
     * @returns True iff move successfully aborted.
     */
    abortMove(workspace: WorkspaceSvg): boolean;
    /**
     * Common clean-up for finish/abort.
     *
     * @param workspace The workspace on which we are moving.
     * @returns The info for the element.
     */
    private preDragEndCleanup;
    /**
     * Common clean-up for finish/abort.
     *
     * @param workspace The workspace on which we are moving.
     * @param info The info for the element.
     */
    private postDragEndCleanup;
    /**
     * Action to move the item being moved in the given direction,
     * constrained to valid attachment points (if any).
     *
     * @param workspace The workspace to move on.
     * @param direction The direction to move the dragged item.
     * @returns True iff this action applies and has been performed.
     */
    moveConstrained(workspace: WorkspaceSvg, direction: Direction): boolean;
    /**
     * Action to move the item being moved in the given direction,
     * without constraint.
     *
     * @param workspace The workspace to move on.
     * @param direction The direction to move the dragged item.
     * @returns True iff this action applies and has been performed.
     */
    moveUnconstrained(workspace: WorkspaceSvg, direction: Direction): boolean;
    /**
     * Monkeypatch: replace the block's drag strategy and cache the old value.
     *
     * @param block The block to patch.
     * @param moveType Whether this is an insert or a move.
     * @param startPoint Where to start the move, or null to use the current
     *     location if any.
     */
    private patchDragStrategy;
    /**
     * Undo the monkeypatching of the block's drag strategy.
     *
     * @param block The block to patch.
     */
    private unpatchDragStrategy;
    /**
     * Scrolls the current element into view.
     *
     * @param workspace The workspace to get current element from.
     * @param padding Amount of spacing to put between the bounds and the edge of
     *     the workspace's viewport.
     */
    private scrollCurrentElementIntoView;
    /**
     * Monkeypatch: override either wouldDeleteDraggable or shouldReturnToStart,
     * based on whether this was an insertion of a new block or a movement of
     * an existing element.
     *
     * @param dragger The dragger to patch.
     * @param moveType Whether this is an insert or a move.
     */
    private patchDragger;
}
/**
 * Information about the currently in-progress move for a given
 * Workspace.
 */
export declare class MoveInfo {
    readonly workspace: WorkspaceSvg;
    readonly draggable: IDraggable & IFocusableNode & IBoundedElement;
    readonly dragger: IDragger;
    readonly blurListener: EventListener;
    /** Total distance moved, in workspace units. */
    totalDelta: utils.Coordinate;
    readonly parentNext: Connection | null;
    readonly parentInput: Connection | null;
    readonly startLocation: utils.Coordinate;
    constructor(workspace: WorkspaceSvg, draggable: IDraggable & IFocusableNode & IBoundedElement, dragger: IDragger, blurListener: EventListener);
    /**
     * Create a fake pointer event for dragging.
     *
     * @param type Which type of pointer event to create.
     * @param direction The direction if this movement is a constrained drag.
     * @returns A synthetic PointerEvent that can be consumed by Blockly's
     *     dragging code.
     */
    fakePointerEvent(type: string, direction?: Direction): PointerEvent;
    /**
     * The keyboard drag may have moved a block to an appropriate location
     * for a preview. Update the saved delta to reflect the element's new
     * location, so that it does not jump during the next unconstrained move.
     */
    updateTotalDelta(): void;
}
//# sourceMappingURL=mover.d.ts.map