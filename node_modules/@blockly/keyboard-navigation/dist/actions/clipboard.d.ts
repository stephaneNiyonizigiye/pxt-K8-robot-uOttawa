/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { Navigation } from '../navigation';
/**
 * Logic and state for cut/copy/paste actions as both keyboard shortcuts
 * and context menu items.
 * In the long term, this will likely merge with the clipboard code in core.
 */
export declare class Clipboard {
    private navigation;
    private options;
    private oldCutShortcut;
    private oldCopyShortcut;
    private oldPasteShortcut;
    constructor(navigation: Navigation, options?: {
        allowCrossWorkspacePaste: boolean;
    });
    /**
     * Install these actions as both keyboard shortcuts and context menu items.
     */
    install(): void;
    /**
     * Uninstall this action as both a keyboard shortcut and a context menu item.
     * N. B. This does *not* currently reinstall the original keyboard shortcuts.
     * You should manually reinstall the previously registered shortcuts (either
     * from core or from another plugin you may be using).
     */
    uninstall(): void;
    /**
     * Create and register the keyboard shortcut for the cut action.
     * Identical to the one in core but adds a toast after successful cut.
     */
    private registerCutShortcut;
    /**
     * Register the cut block action as a context menu item.
     * The context menu uses its own preconditionFn (that doesn't check
     * if a gesture is in progress, because one always is in the context
     * menu). It calls the cut callback that is shared between keyboard
     * and context menu.
     */
    private registerCutContextMenuAction;
    /**
     * Precondition function for the cut context menu. This wraps the core cut
     * precondition to support context menus.
     *
     * @param scope scope of the shortcut or context menu item
     * @returns 'enabled' if the node can be cut, 'disabled' otherwise.
     */
    private cutPrecondition;
    /**
     * The callback for the cut action. Uses the registered version of the cut callback
     * to perform the cut logic, then pops a toast if cut happened.
     *
     * @param workspace Workspace where shortcut happened.
     * @param e menu open event or keyboard event
     * @param shortcut keyboard shortcut or undefined for context menus
     * @param scope scope of the shortcut or context menu item
     * @returns true if a cut happened, false otherwise
     */
    private cutCallback;
    /**
     * Create and register the keyboard shortcut for the copy action.
     * Identical to the one in core but pops a toast after succesful copy.
     */
    private registerCopyShortcut;
    /**
     * Register the copy block action as a context menu item.
     * The context menu uses its own preconditionFn (that doesn't check
     * if a gesture is in progress, because one always is in the context
     * menu). It calls the copy callback that is shared between keyboard
     * and context menu.
     */
    private registerCopyContextMenuAction;
    /**
     * Precondition function for the copy context menu. This wraps the core copy
     * precondition to support context menus.
     *
     * @param scope scope of the shortcut or context menu item
     * @returns 'enabled' if the node can be copied, 'disabled' otherwise.
     */
    private copyPrecondition;
    /**
     * The callback for the copy action. Uses the registered version of the copy callback
     * to perform the copy logic, then pops a toast if copy happened.
     *
     * @param workspace Workspace where shortcut happened.
     * @param e menu open event or keyboard event
     * @param shortcut keyboard shortcut or undefined for context menus
     * @param scope scope of the shortcut or context menu item
     * @returns true if a copy happened, false otherwise
     */
    private copyCallback;
    /**
     * Create and register the keyboard shortcut for the paste action.
     * Identical to the one in core but clears any paste toasts after.
     */
    private registerPasteShortcut;
    /**
     * Register the paste block action as a context menu item.
     * The context menu uses its own preconditionFn (that doesn't check
     * if a gesture is in progress, because one always is in the context
     * menu). It calls the paste callback that is shared between keyboard
     * and context menu.
     */
    private registerPasteContextMenuAction;
    /**
     * Get the workspace to paste into based on which type of thing the menu was opened on.
     *
     * @param scope scope of shortcut or context menu item
     * @returns WorkspaceSvg to paste into or undefined
     */
    private getPasteWorkspace;
    /**
     * Precondition function for the paste context menu. This wraps the core
     * paste precondition to support context menus.
     *
     * @param scope scope of the shortcut or context menu item
     * @returns 'enabled' if the node can be pasted, 'disabled' otherwise.
     */
    private pastePrecondition;
    /**
     * The callback for the paste action. Uses the registered version of the paste callback
     * to perform the paste logic, then clears any toasts about pasting.
     *
     * @param workspace Workspace where shortcut happened.
     * @param e menu open event or keyboard event
     * @param shortcut keyboard shortcut or undefined for context menus
     * @param scope scope of the shortcut or context menu item
     * @returns true if a paste happened, false otherwise
     */
    private pasteCallback;
}
//# sourceMappingURL=clipboard.d.ts.map