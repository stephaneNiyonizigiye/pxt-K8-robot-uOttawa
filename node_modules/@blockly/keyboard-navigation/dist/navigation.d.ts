/**
 * @license
 * Copyright 2021 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
/**
 * @fileoverview Holds all methods necessary to use Blockly through the
 * keyboard.
 * @author aschmiedt@google.com (Abby Schmiedt)
 */
import * as Blockly from 'blockly/core';
import * as Constants from './constants';
/**
 * Class that holds all methods necessary for keyboard navigation to work.
 */
export declare class Navigation {
    /**
     * Wrapper for method that deals with workspace changes.
     * Used for removing change listener.
     */
    protected wsChangeWrapper: (e: Blockly.Events.Abstract) => void;
    /**
     * Wrapper for method that deals with flyout changes.
     * Used for removing change listener.
     */
    protected flyoutChangeWrapper: (e: Blockly.Events.Abstract) => void;
    /**
     * The list of registered workspaces.
     * Used when removing change listeners in dispose.
     */
    protected workspaces: Blockly.WorkspaceSvg[];
    /**
     * Constructor for keyboard navigation.
     */
    constructor();
    /**
     * Adds all necessary change listeners and markers to a workspace for keyboard
     * navigation to work. This must be called for keyboard navigation to work
     * on a workspace.
     *
     * @param workspace The workspace to add keyboard navigation to.
     */
    addWorkspace(workspace: Blockly.WorkspaceSvg): void;
    /**
     * Removes all keyboard navigation change listeners and markers.
     *
     * @param workspace The workspace to remove keyboard navigation from.
     */
    removeWorkspace(workspace: Blockly.WorkspaceSvg): void;
    /**
     * Gets the navigation state of the current workspace.
     *
     * Note that this assumes a workspace with passive focus (including for its
     * toolbox or flyout) has a state of NOWHERE.
     *
     * @returns The state of the given workspace.
     */
    getState(): Constants.STATE;
    /**
     * Adds all event listeners and cursors to the flyout that are needed for
     * keyboard navigation to work.
     *
     * @param flyout The flyout to add a cursor and change listeners to.
     */
    addFlyout(flyout: Blockly.IFlyout): void;
    /**
     * Removes all change listeners from the flyout that are needed for
     * keyboard navigation to work.
     *
     * @param flyout The flyout to add a cursor and event listeners to.
     */
    removeFlyout(flyout: Blockly.IFlyout): void;
    /**
     * Updates the state of keyboard navigation and the position of the cursor
     * based on workspace events.
     *
     * @param e The Blockly event to process.
     */
    workspaceChangeListener(e: Blockly.Events.Abstract): void;
    /**
     * Updates the state of keyboard navigation and the position of the cursor
     * based on events emitted from the flyout's workspace.
     *
     * @param e The Blockly event to process.
     */
    flyoutChangeListener(e: Blockly.Events.Abstract): void;
    private isFlyoutItemDisposed;
    /**
     * Moves the cursor to the block level when the block the cursor is on
     * mutates.
     *
     * @param workspace The workspace the cursor belongs
     *     to.
     * @param e The Blockly event to process.
     */
    handleBlockMutation(workspace: Blockly.WorkspaceSvg, e: Blockly.Events.BlockChange): void;
    /**
     * Handles when a user clicks on a block in the flyout by moving the cursor
     * to that stack of blocks and setting the state of navigation to the flyout.
     *
     * @param mainWorkspace The workspace the user clicked on.
     * @param block The block the user clicked on.
     */
    handleBlockClickInFlyout(mainWorkspace: Blockly.WorkspaceSvg, block: Blockly.BlockSvg): void;
    /**
     * Move the flyout cursor to the preferred end if unset (as it is initially despite
     * the types) or on a disposed item.
     *
     * @param workspace The workspace.
     * @param prefer The preferred default position.
     * @return true if the cursor location was defaulted.
     */
    defaultFlyoutCursorIfNeeded(workspace: Blockly.WorkspaceSvg, prefer?: 'first' | 'last'): boolean;
    /**
     * Sets the cursor location when focusing the workspace.
     * Tries the following, in order, stopping after the first success:
     *  - Resume editing by returning the cursor to its previous location, if valid.
     *  - Move the cursor to the top connection point on on the first top block.
     *  - Move the cursor to the default location on the workspace.
     *
     * @param workspace The main Blockly workspace.
     * @param prefer The preferred default position.
     * @return true if the cursor location was defaulted.
     */
    defaultWorkspaceCursorPositionIfNeeded(workspace: Blockly.WorkspaceSvg, prefer?: 'first' | 'last'): boolean | undefined;
    /**
     * Gets the cursor on the flyout's workspace.
     *
     * @param workspace The main workspace the flyout is on.
     * @returns The flyout's cursor or null if no flyout exists.
     */
    getFlyoutCursor(workspace: Blockly.WorkspaceSvg): Blockly.LineCursor | null;
    /**
     * Tries to intelligently connect the blocks or connections
     * represented by the given nodes, based on node types and locations.
     *
     * @param stationaryNode The first node to connect.
     * @param movingBlock The block we're moving.
     * @returns True if the key was handled; false if something went
     *     wrong.
     */
    findInsertStartPoint(stationaryNode: Blockly.IFocusableNode, movingBlock: Blockly.BlockSvg): Blockly.RenderedConnection | null;
    /**
     * Tries to intelligently connect the blocks or connections
     * represented by the given nodes, based on node types and locations.
     *
     * @param stationaryNode The first node to connect.
     * @param movingBlock The block we're moving.
     * @returns True if the connection was successful, false otherwise.
     */
    tryToConnectBlock(stationaryNode: Blockly.IFocusableNode, movingBlock: Blockly.BlockSvg): boolean;
    /**
     * Disconnects the child block from its parent block. No-op if the two given
     * connections are unrelated.
     *
     * @param movingConnection The connection that is being moved.
     * @param destConnection The connection to be moved to.
     */
    disconnectChild(movingConnection: Blockly.RenderedConnection, destConnection: Blockly.RenderedConnection): void;
    /**
     * Tries to connect the  given connections.
     *
     * If the given connections are not compatible try finding compatible
     * connections on the source blocks of the given connections.
     *
     * @param movingConnection The connection that is being moved.
     * @param destConnection The connection to be moved to.
     * @returns True if the two connections or their target connections
     *     were connected, false otherwise.
     */
    connect(movingConnection: Blockly.RenderedConnection | null, destConnection: Blockly.RenderedConnection | null): boolean;
    /**
     * Finds the inferior connection on the source block if the given connection
     * is superior.
     *
     * @param connection The connection trying to be connected.
     * @returns The inferior connection or null if none exists.
     */
    getInferiorConnection(connection: Blockly.RenderedConnection | null): Blockly.RenderedConnection | null;
    /**
     * Finds a superior connection on the source block if the given connection is
     * inferior.
     *
     * @param connection The connection trying to be connected.
     * @returns The superior connection or null if none exists.
     */
    getSuperiorConnection(connection: Blockly.RenderedConnection | null): Blockly.RenderedConnection | null;
    /**
     * Moves the moving connection to the target connection and connects them.
     *
     * @param movingConnection The connection that is being moved.
     * @param destConnection The connection to be moved to.
     * @returns True if the connections were connected, false otherwise.
     */
    moveAndConnect(movingConnection: Blockly.RenderedConnection | null, destConnection: Blockly.RenderedConnection | null): boolean;
    /**
     * Tries to connect the given block to the destination connection, making an
     * intelligent guess about which connection to use on the moving block.
     *
     * @param block The block to move.
     * @param destConnection The connection to
     *     connect to.
     * @returns Whether the connection was successful.
     */
    insertBlock(block: Blockly.BlockSvg, destConnection: Blockly.RenderedConnection): boolean;
    /**
     * Enables accessibility mode.
     *
     * @param workspace The workspace to enable keyboard
     *     accessibility mode on.
     */
    enableKeyboardAccessibility(workspace: Blockly.WorkspaceSvg): void;
    /**
     * Disables accessibility mode.
     *
     * @param workspace The workspace to disable keyboard
     *     accessibility mode on.
     */
    disableKeyboardAccessibility(workspace: Blockly.WorkspaceSvg): void;
    /**
     * Navigation log handler. If loggingCallback is defined, use it.
     * Otherwise just log to the console.log.
     *
     * @param msg The message to log.
     */
    log(msg: string): void;
    /**
     * Navigation warning handler. If loggingCallback is defined, use it.
     * Otherwise call console.warn.
     *
     * @param msg The warning message.
     */
    warn(msg: string): void;
    /**
     * Navigation error handler. If loggingCallback is defined, use it.
     * Otherwise call console.error.
     *
     * @param msg The error message.
     */
    error(msg: string): void;
    /**
     * Save the current cursor location and open the toolbox or flyout
     * to select and insert a block.
     *
     * @param workspace The active workspace.
     */
    openToolboxOrFlyout(workspace: Blockly.WorkspaceSvg): void;
    /**
     * Pastes the copied block to the marked location if possible or
     * onto the workspace otherwise.
     *
     * @param copyData The data to paste into the workspace.
     * @param workspace The workspace to paste the data into.
     * @returns True if the paste was sucessful, false otherwise.
     */
    paste(copyData: Blockly.ICopyData, workspace: Blockly.WorkspaceSvg): boolean;
    /**
     * Determines whether keyboard navigation should be allowed based on the
     * current state of the workspace.
     *
     * A return value of 'true' generally indicates that either the workspace,
     * toolbox or flyout has enabled keyboard navigation and is currently in a
     * state (e.g. focus) that can support keyboard navigation.
     *
     * @param workspace the workspace in which keyboard navigation may be allowed.
     * @returns whether keyboard navigation is currently allowed.
     */
    canCurrentlyNavigate(workspace: Blockly.WorkspaceSvg): boolean;
    /**
     * Determines whether the provided workspace is currently keyboard navigable
     * and editable.
     *
     * For the navigability criteria, see canCurrentlyKeyboardNavigate.
     *
     * @param workspace the workspace in which keyboard editing may be allowed.
     * @returns whether keyboard navigation and editing is currently allowed.
     */
    canCurrentlyEdit(workspace: Blockly.WorkspaceSvg): boolean;
    /**
     * Removes the change listeners on all registered workspaces.
     */
    dispose(): void;
}
//# sourceMappingURL=navigation.d.ts.map