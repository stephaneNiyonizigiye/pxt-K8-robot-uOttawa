/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */
import { BlockSvg, RenderedConnection, dragging, utils } from 'blockly';
import { MoveType } from './actions/mover';
interface ConnectionCandidate {
    /** A connection on the dragging stack that is compatible with neighbour. */
    local: RenderedConnection;
    /** A nearby connection that is compatible with local. */
    neighbour: RenderedConnection;
    /** The distance between the local connection and the neighbour connection. */
    distance: number;
}
export declare class KeyboardDragStrategy extends dragging.BlockDragStrategy {
    private block;
    moveType: MoveType;
    private startPoint;
    /** Which direction the current constrained drag is in, if any. */
    private currentDragDirection;
    /** Where a constrained movement should start when traversing the tree. */
    private searchNode;
    constructor(block: BlockSvg, moveType: MoveType, startPoint: RenderedConnection | null);
    startDrag(e?: PointerEvent): void;
    drag(newLoc: utils.Coordinate, e?: PointerEvent): void;
    endDrag(e?: PointerEvent): void;
    /**
     * Returns the next compatible connection in keyboard navigation order,
     * based on the input direction.
     * Always resumes the search at the last valid connection that was tried.
     *
     * @param draggingBlock The block where the drag started.
     * @returns A valid connection candidate, or null if none was found.
     */
    private getConstrainedConnectionCandidate;
    /**
     * Get the nearest valid candidate connection, regardless of direction.
     * TODO(github.com/google/blockly/issues/8869): Replace with an
     * override of `getSearchRadius` when implemented in core.
     *
     * @param localConns The list of connections on the dragging block(s) that are
     *     available to connect to.
     * @returns A candidate connection and radius, or null if none was found.
     */
    findNearestCandidate(localConns: RenderedConnection[]): ConnectionCandidate | null;
    /**
     * Get the nearest valid candidate connection in traversal order.
     *
     * @param draggingBlock The root block being dragged.
     * @param localConns The list of connections on the dragging block(s) that are
     *     available to connect to.
     * @returns A candidate connection and radius, or null if none was found.
     */
    findTraversalCandidate(draggingBlock: BlockSvg, localConns: RenderedConnection[]): ConnectionCandidate | null;
    currCandidateIsBetter(currCandidate: ConnectionCandidate, delta: utils.Coordinate, newCandidate: ConnectionCandidate): boolean;
    getConnectionCandidate(draggingBlock: BlockSvg, delta: utils.Coordinate): ConnectionCandidate | null;
    /**
     * Get whether the most recent drag event represents a constrained
     * keyboard drag.
     *
     * @returns true if the current movement is constrained, otherwise false.
     */
    private isConstrainedMovement;
    /**
     * Force the preview (replacement or insertion marker) to be shown
     * immediately. Keyboard drags should always show a preview, even when
     * the drag has just started; this forces it.
     */
    private forceShowPreview;
    /**
     * Create a candidate representing where the block was previously connected.
     * Used to render the block position after picking up the block but before
     * moving during a drag.
     *
     * @returns A connection candidate representing where the block was at the
     *     start of the drag.
     */
    private createInitialCandidate;
    shouldHealStack(e: PointerEvent | undefined): boolean;
}
export {};
//# sourceMappingURL=keyboard_drag_strategy.d.ts.map